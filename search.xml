<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>MarkDown语法</title>
    <url>/Lei_Blog/2024/11/01/MarkDown%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>MarkDown基础语法</p>
<h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>使用符号（#&#x2F;&#x3D;），最多支持六级标题，最好在符号后加上空格<br></p>
<ul>
<li># &emsp;一级标题<br></li>
<li>## &emsp;二级标题<br></li>
<li>### &emsp;三级标题<br></li>
</ul>
<h2 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h2><h3 id="语法如下"><a href="#语法如下" class="headerlink" title="语法如下"></a>语法如下</h3><ul>
<li>如果行与行之间没有空行则会被视为一段，若之间有有空行则视为不同段落</li>
<li>空行是指行内什么都没有，或只有空格和制表符</li>
<li>如果想在段内直接换行则需要在上一行的结尾插入两个以上的空格然后回车</li>
<li>当超过80个字符或以（。！?）等结尾时建议换行，或URL较长时换行</li>
</ul>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="有序列表语法如下"><a href="#有序列表语法如下" class="headerlink" title="有序列表语法如下"></a>有序列表语法如下</h3><ul>
<li>数字序号 + 英文句号 + 空格 + 列表内容     <ol>
<li>我是第一行</li>
<li>我是第二行</li>
<li>……..</li>
</ol>
</li>
<li>无序列表如下<br>*&#x2F;+&#x2F;- + 空格 + 列表内容</li>
</ul>
<h3 id="列表嵌套语法如下"><a href="#列表嵌套语法如下" class="headerlink" title="列表嵌套语法如下"></a>列表嵌套语法如下</h3><ul>
<li>- 第一层列表<br>tab + 第二层列表<br>tab+ tab + 第三层列表<br><br></li>
<li>第一层列表<ul>
<li>第二层列表<ul>
<li>第三层列表<ul>
<li>…..</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="图片插入"><a href="#图片插入" class="headerlink" title="图片插入"></a>图片插入</h2><h3 id="图片插入语法文字链接如下"><a href="#图片插入语法文字链接如下" class="headerlink" title="图片插入语法文字链接如下"></a>图片插入语法文字链接如下</h3><ul>
<li>![图片替代文字](图片替代地址)</li>
<li>[链接文字](链接地址)<ul>
<li>引用连接：<br><br>   [链接文字][链接标记]<br>   ……<br>   在底部:<br>   [链接标记]: 链接地址</li>
</ul>
</li>
</ul>
<h3 id="引用链接"><a href="#引用链接" class="headerlink" title="引用链接"></a>引用链接</h3><ul>
<li>链接标记可以有字母、数字、空格和标点符号</li>
<li>链接标记不区分大小写</li>
<li>定义的链接内容可以放在当前文件的任意位置、建议放在页尾巴</li>
<li>当链接地址为网络地址时要以http&#x2F;https开头，否则会被标识为本地地址</li>
</ul>
<h2 id="行内代码块"><a href="#行内代码块" class="headerlink" title="行内代码块"></a>行内代码块</h2><ul>
<li><p>行内代码引用要使用`包裹，语法如下<br>使用`cd..` -&gt; <code>CD .. </code> </p>
</li>
<li><p>代码块.TAB键或者4个空格开头</p>
<pre><code>  def test_print():
      pass
</code></pre>
</li>
</ul>
<h3 id="使用规范"><a href="#使用规范" class="headerlink" title="使用规范"></a>使用规范</h3><pre><code>    <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;aabb&quot;</span>)</span><br></pre></td></tr></table></figure>

    <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">include&lt;iostream&gt;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;test&quot;</span></span></span><br><span class="line">test</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">which</span> bash</span></span><br><span class="line">/bin/bash</span><br></pre></td></tr></table></figure>
</code></pre>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><h3 id="语法如下-1"><a href="#语法如下-1" class="headerlink" title="语法如下"></a>语法如下</h3><p>引用由&gt;+ 引用内容来标记</p>
<ul>
<li>多行引用也可以在每一行的开有都插入&gt;</li>
<li>在引用中可以嵌套引用</li>
<li>在引用中可以使用其它MarkDown语法</li>
<li>段落与换行的格式在引用中也是可以适用的<ul>
<li>示例    <blockquote>
<p>例子1   </p>
</blockquote>
 正常的句子<blockquote>
<p>多行引用第一行<br> 第二行</p>
</blockquote>
</li>
<li>引用嵌套<blockquote>
<p>引用嵌套 &gt;</p>
<blockquote>
<p>被嵌套部分 &gt;  &gt;</p>
</blockquote>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="GFM语法"><a href="#GFM语法" class="headerlink" title="GFM语法"></a>GFM语法</h2><h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><ul>
<li>~~被删除的文字~~<br><del>被删除的文字</del></li>
</ul>
<h3 id="表情符号"><a href="#表情符号" class="headerlink" title="表情符号"></a>表情符号</h3><ul>
<li>表情符号 :表情代码:<br>   :smile:<br>   :laughing:<br>   :+1:</li>
</ul>
<h3 id="自动链接"><a href="#自动链接" class="headerlink" title="自动链接"></a>自动链接</h3><ul>
<li>由&lt;&gt;包裹的URL地址被自动识别并解析为超链接<br>百度<a href="https://www.baidu.com/">https://www.baidu.com</a></li>
</ul>
<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><ul>
<li>表格语法如下     <br> 
\| 表头1 \| 表头2 \| 表头3 \|    
\|----  \|---- \| ----\|    
\| 内容1 \| 内容2\| 内容3\|   
<br>

<table>
<thead>
<tr>
<th>表头1</th>
<th>表头2</th>
<th>表头3</th>
</tr>
</thead>
<tbody><tr>
<td>内容1</td>
<td>内容2</td>
<td>内容3</td>
</tr>
<tr>
<td>内容1</td>
<td>内容2</td>
<td>内容3</td>
</tr>
</tbody></table>
</li>
<li>默认对齐<ul>
<li><p>左对齐【默认】 :</p>
</li>
<li><p>右对齐   -：</p>
</li>
<li><p>中间对齐 :-:    </p>
<p>中间对齐 |:—-:|:—-:|:—-:|     </p>
<table>
<thead>
<tr>
<th align="center">表头1</th>
<th align="center">表头2</th>
<th align="center">表头3</th>
</tr>
</thead>
<tbody><tr>
<td align="center">内容1</td>
<td align="center">内容2</td>
<td align="center">内容3</td>
</tr>
<tr>
<td align="center">内容1</td>
<td align="center">内容2</td>
<td align="center">内容3</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<h3 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h3><ul>
<li><p>任务列表以-+ 开头，由[+空格/X+]组成</p>
</li>
<li><p>X 可以有大小写,看编辑器支持，推荐小写，当中括号内为x时为选中状态    </p>
<ul>
<li><p><input checked="" disabled="" type="checkbox"> 
吃</p>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
喝</p>
</li>
<li><p><input disabled="" type="checkbox"> 
玩  </p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 吃 <ul>
<li><input disabled="" type="checkbox"> 吃鱼</li>
<li><input disabled="" type="checkbox"> 吃饭</li>
</ul>
</li>
</ul>
</li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- [x] 吃</span><br><span class="line">- [x] 喝</span><br><span class="line">- [ ] 玩  </span><br><span class="line"></span><br><span class="line">  - [x] 吃 </span><br><span class="line">    - [ ] 吃鱼</span><br><span class="line">    - [ ] 吃饭   </span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="锚点（书签）"><a href="#锚点（书签）" class="headerlink" title="锚点（书签）"></a>锚点（书签）</h3><p>[锚点描述](#锚点名)</p>
<ul>
<li>锚点名建议使用字母和数字，锚点名是区分大小写的</li>
<li>在锚点中不能含有空格也不能含有特殊字符<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[第一章](#第一章)</span><br><span class="line">[第二章](#第二章)</span><br></pre></td></tr></table></figure>

  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## 第一章</span><br><span class="line">baba baba baba</span><br><span class="line">## 第二章</span><br><span class="line">dcdc dcdc dcdc</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>test</title>
    <url>/Lei_Blog/2024/11/01/test/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>C++模板与泛型_基础_01</title>
    <url>/Lei_Blog/2024/11/02/C-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B-%E5%9F%BA%E7%A1%80-01/</url>
    <content><![CDATA[<h1 id="模板与基础知识"><a href="#模板与基础知识" class="headerlink" title="模板与基础知识"></a>模板与基础知识</h1><h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><ul>
<li>基础范例  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">Sub</span><span class="params">(T tv1, T tv2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tv1 - tv2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  在main中添加如下代码  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> subv = <span class="built_in">Sub</span>(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">std::cout &lt;&lt; subv &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
  上述是一个函数模板的典型范例，T为模板参数，准确说是类型模板参数，因为其代表一个类型。    </li>
<li>实例化<br>  用具体的类型代替类型模板参数的过程叫做实例化，也称之为代码生成器。</li>
</ul>
<h2 id="模板参数推断"><a href="#模板参数推断" class="headerlink" title="模板参数推断"></a>模板参数推断</h2><ul>
<li>常规的参数推断  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U, <span class="keyword">typename</span> V&gt;</span></span><br><span class="line"><span class="function">V <span class="title">Add</span><span class="params">(T tv1, U tv2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tv1 + tv2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  这个函数模板中定义了3个类型模板参数T、U，V。当如此实例化并调用<code>std::cout &lt;&lt; Add(15, 17) &lt;&lt; std::endl;</code>，一定会发生错误。<br>  因为编译器无法推断出返回值类型V，因此只能手动指定类型，如：<code>std::cout &lt;&lt; Add&lt;..., ..., double&gt;(15, 17) &lt;&lt; std::endl;</code>,<br>  虽然可以指定一定量的模板参数，但编译器是按顺序来知道指定的类型的，只能按顺序去指定模板参数。例如<code>Add&lt;double&gt;(...,...)</code>就会发生错误，<br>  如改成以下方式就可以成功编译,让编译器去推断T，U：  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> V, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">V <span class="title">Add</span><span class="params">(T tv1, U tv2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tv1 + tv2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>关键字推断auto, decltype<br>  auto 结合decltype构成返回类型后置语法，代码如下：  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Add</span><span class="params">(T tv1, U tv2)</span> -&gt; <span class="title">decltype</span><span class="params">(tv1 + tv2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tv1 + tv2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>自动推断，指定推断，指定空模板参数列表     <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">myDouble</span> <span class="params">(T temp_value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> temp_value * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  自动推断<code>int result = myDouble(12)</code>, 此时推断出T为int类型<br>  指定推断<code>int result = myDouble&lt;int&gt;(12)</code>,指定类型为int类型<br>  指定空模板参数<code>auto result = myDouble&lt;&gt;(12.6)</code>,此时编译器根据函数参数推断出T为double类型，<br>  当前情况与<code>auto result = myDouble(12.6)</code>没什么不同，若存在一个普通的myDouble函数，&lt;&gt;就会<br>  发生作用:      <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">myDouble</span> <span class="params">(<span class="type">double</span> temp_value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> temp_value * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  若进行这般调用<code>auto result = myDouble(12.6)</code>，其会调用普通函数。</li>
</ul>
<h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><p>函数（函数模板）重载的概念：函数名相同，但函数参数或类型不同。编译器会更具具体情况选择编译器认为最合适的函数<br>模板实例化或者普通函数进行调用</p>
<ul>
<li>范例  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myfunc</span><span class="params">(T tmpvalue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;myfunc(T)执行了&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  在main中插入如下代码  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">myfunc</span>(<span class="number">12</span>);</span><br><span class="line"><span class="type">char</span>* p = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="built_in">myfunc</span>(p);</span><br></pre></td></tr></table></figure>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">myfunc(T)执行了</span><br><span class="line">myfunc(T)执行了</span><br></pre></td></tr></table></figure>
  以上编译器可以根据不同的参数实例化不同的模板,现添加如下代码  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myfunc</span><span class="params">(T* tmpvalue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;myfunc(T*)执行了&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  重复上过程，和推断的没有差别  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">myfunc(T)执行了</span><br><span class="line">myfunc(T*)执行了</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="特化"><a href="#特化" class="headerlink" title="特化"></a>特化</h2><p>泛化的意思是“大众化”,特化指的是”大众化“中的指定特征“集合”</p>
<ul>
<li>全特化：模板中所有的参数都指定为特定类型<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tfunc</span><span class="params">(T&amp; tmprv, U&amp; tmprv2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::cout &lt;&lt; “泛化版本执行了” &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">tfunc</span>&lt;<span class="type">int</span>, <span class="type">double</span>&gt;(<span class="type">int</span>&amp; tmprv, <span class="type">double</span>&amp; tmprv2)</span><br><span class="line">&#123;</span><br><span class="line">  std::cout &lt;&lt; “全特化版本执行了” &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> k = <span class="number">12</span>;</span><br><span class="line"><span class="type">double</span> db = <span class="number">15.8</span>;</span><br><span class="line"><span class="built_in">tfunc</span>(k, db);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">全特化版本执行了</span><br></pre></td></tr></table></figure></li>
<li>偏特化(局部特化)<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tfunc</span><span class="params">(T&amp; tmprv, U&amp; tmprv2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::cout &lt;&lt; “泛化版本执行了” &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">模板数量上的偏特化 实际上这条编译会出错，数量上来讲函数模板不能篇特化</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">template&lt;typename U&gt;</span></span><br><span class="line"><span class="comment">void tfunc&lt;int, U&gt;(int&amp; tmprv, U&amp; tmprv2)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  std::cout &lt;&lt; “数量上偏特化版本执行了” &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板范围上的偏特化 实际上是函数模板的重载</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tfunc</span><span class="params">(<span class="type">const</span> T&amp; tmprv, U&amp; tmprv2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::cout &lt;&lt; “模板范围上的偏特化执行了” &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">tfunc</span>(a, b);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">模板范围上的偏特化执行了</span><br></pre></td></tr></table></figure></li>
<li>通过重载实现函数模板的偏特化<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tfunc</span><span class="params">(<span class="type">double</span>&amp; tmprv, U&amp; tmprv2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::cout &lt;&lt; “模板参数数量上的偏特化执行了（重载版本）” &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* p = <span class="string">&quot;aaaaa&quot;</span>;</span><br><span class="line"><span class="type">int</span> i = <span class="number">12</span>;</span><br><span class="line"><span class="built_in">tfunc</span>(p, i);</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> j = <span class="number">19.5</span>;</span><br><span class="line"><span class="built_in">tfunc</span>(j, i);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">泛化版本执行了</span><br><span class="line">模板参数数量上的偏特化执行了（重载版本）</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="非类型模板参数"><a href="#非类型模板参数" class="headerlink" title="非类型模板参数"></a>非类型模板参数</h2><p>模板参数不但可以是一个类型，也可以是一个普通的参数，参数还可以是一个默认值</p>
<ul>
<li>范例<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U, <span class="type">int</span> val </span>= <span class="number">0</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Add</span><span class="params">(T tv1, U tv2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> tv1 + tv2 + val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="built_in">Add</span>&lt;<span class="type">float</span>, <span class="type">float</span>&gt;(<span class="number">1.1f</span>, <span class="number">12.3f</span>) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">Add</span>&lt;<span class="type">float</span>, <span class="type">float</span>, <span class="number">1</span>&gt;(<span class="number">1.1f</span>, <span class="number">12.3f</span>) &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">13.4</span><br><span class="line">14.4</span><br></pre></td></tr></table></figure>
以上要注意的点<ul>
<li>在指定非类型模板参数时，一般给的是常量，否则编译报错。</li>
<li>并不是任何类型的参数都可以，int可以，但float, double类型不行，类类型也不可以，不过double* 等指针类型可以</li>
<li>主要有整型或枚举型，指针类型, 左值引用类型,auto或decltype(auto)这个用法…..</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++泛型</tag>
      </tags>
  </entry>
  <entry>
    <title>vsftpd简单安装和使用</title>
    <url>/Lei_Blog/2024/11/03/vsftpd%E7%AE%80%E5%8D%95%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="Ubuntu系统FTP服务器搭建"><a href="#Ubuntu系统FTP服务器搭建" class="headerlink" title="Ubuntu系统FTP服务器搭建"></a>Ubuntu系统FTP服务器搭建</h2><h3 id="安装vsftpd软件"><a href="#安装vsftpd软件" class="headerlink" title="安装vsftpd软件"></a>安装vsftpd软件</h3><p><a href="https://www.cnblogs.com/HOsystem/p/16629572.html">详细配置说明链接</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install vsftpd</span><br><span class="line"> </span><br><span class="line"># 设置开机启动并启动ftp服务</span><br><span class="line">systemctl enable vsftpd</span><br><span class="line">systemctl start vsftpd</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查看其运行状态</span><br><span class="line">systemctl  status vsftpd</span><br><span class="line">#重启服务</span><br><span class="line">systemctl  restart vsftpd</span><br></pre></td></tr></table></figure>

<h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo useradd -d /home/ftp/ftp_root -m ftpadmin</span><br><span class="line">sudo passwd ftpadmin</span><br><span class="line">输入密码：</span><br><span class="line">再次输入密码：</span><br><span class="line">chmod -R 777 /home/ftp/ftp_root</span><br></pre></td></tr></table></figure>

<h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo nano /etc/vsftpd.conf</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">存在的修改成酱紫：</span><br><span class="line">listen=NO # 阻止 vsftpd 在独立模式下运行</span><br><span class="line">listen_ipv6=YES # vsftpd 将监听 ipv6 而不是 IPv4，你可以根据你的网络情况设置</span><br><span class="line">anonymous_enable=NO # 关闭匿名登录</span><br><span class="line">local_enable=YES # 允许本地用户登录</span><br><span class="line">write_enable=YES # 启用可以修改文件的 FTP 命令</span><br><span class="line">local_umask=022 # 本地用户创建文件的 umask 值</span><br><span class="line">dirmessage_enable=YES # 当用户第一次进入新目录时显示提示消息</span><br><span class="line">xferlog_enable=YES # 一个存有详细的上传和下载信息的日志文件</span><br><span class="line">connect_from_port_20=YES # 在服务器上针对 PORT 类型的连接使用端口 20（FTP 数据）</span><br><span class="line">xferlog_std_format=YES # 保持标准日志文件格式</span><br><span class="line">pam_service_name=vsftpd # vsftpd 将使用的 PAM 验证设备的名字</span><br></pre></td></tr></table></figure>
<p>修改配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/etc/vsftpd.conf </span><br><span class="line">将pam_service_name=vsftpd   修改为：pam_service_name=ftp</span><br></pre></td></tr></table></figure>
<p>最后添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">userlist_deny=NO</span><br><span class="line">userlist_enable=YES</span><br><span class="line">userlist_file=/etc/vsftpd.allowed_users</span><br><span class="line"></span><br><span class="line">nano /etc/vsftpd.chroot_list</span><br><span class="line">#输入ftpadmin后保存退出</span><br><span class="line">开启端口 数据传输20 命令交互21</span><br><span class="line">sudo ufw allow 20</span><br><span class="line">sudo ufw allow 21</span><br><span class="line">#重启服务</span><br><span class="line">systemctl start vsftpd</span><br></pre></td></tr></table></figure>


<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ftp localhost</span></span><br><span class="line">Connected to localhost.</span><br><span class="line">500 OOPS: cannot read user list file:/etc/vsftpd.allowed_users</span><br><span class="line"><span class="meta prompt_">ftp&gt; </span><span class="language-bash"><span class="built_in">exit</span></span></span><br></pre></td></tr></table></figure>
<h2 id="远程登陆"><a href="#远程登陆" class="headerlink" title="远程登陆"></a>远程登陆</h2><h3 id="安装filezilla"><a href="#安装filezilla" class="headerlink" title="安装filezilla"></a>安装filezilla</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install filezilla</span><br></pre></td></tr></table></figure>
<p>输入相关选项即可连接</p>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>vsftpd</tag>
      </tags>
  </entry>
  <entry>
    <title>C++模板与泛型_基础_02</title>
    <url>/Lei_Blog/2024/11/05/C-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B-%E5%9F%BA%E7%A1%80-02/</url>
    <content><![CDATA[<h2 id="类模板、变量模板与别名模板"><a href="#类模板、变量模板与别名模板" class="headerlink" title="类模板、变量模板与别名模板"></a>类模板、变量模板与别名模板</h2><h3 id="类模板的基本范例和模板参数的推断"><a href="#类模板的基本范例和模板参数的推断" class="headerlink" title="类模板的基本范例和模板参数的推断"></a>类模板的基本范例和模板参数的推断</h3><p>类模板，产生类的模具，通过给定的模板参数，生成具体的类</p>
<ul>
<li>基本范例<br>类模板的声明和实现一般都放在同一个头文件中,以下是自定义一个vector<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myvector</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> T* myiterator;</span><br><span class="line">  <span class="comment">//构造函数</span></span><br><span class="line">  <span class="built_in">myvector</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  赋值运算符重载</span></span><br><span class="line"><span class="comment">  在类模板内不使用模板民myvector并不需要提供模板参数，当然也可以提供，可以写成</span></span><br><span class="line"><span class="comment">  myvector&lt;T&gt; </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function">myvector&amp; <span class="title">operator</span><span class="params">(<span class="type">const</span> myvector &amp;)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">myfunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;myfunc 被调用&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">myiterator <span class="title">mybegin</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">myiterator <span class="title">myend</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类外构造</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">myvector&lt;T&gt;::<span class="built_in">myvector</span>()&#123;&#125;</span><br></pre></td></tr></table></figure>
在main函数中插入<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">myvector&lt;<span class="type">int</span>&gt; tmpvec; <span class="comment">// 模板内的T被替换为int</span></span><br><span class="line">tmpvec.<span class="built_in">myfunc</span>();  <span class="comment">// 调用类模板中的普通成员函数</span></span><br></pre></td></tr></table></figure>
运行结果<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">myfunc 被调用</span><br></pre></td></tr></table></figure>
在以上代码中并没有写赋值运算符代码，因为在类模板中只有被调用这些函数编译器才实例化相关代码<br>如果模板中有静态成员函数那么当这个静态成员函数被调用的时候才会实例化，在上代码插入函数，如下<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">mystaticfunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;mystaticfunc() 被调用了&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在main函数中插入<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">myvector&lt;std::string&gt;::<span class="built_in">mystaticfunc</span>();</span><br></pre></td></tr></table></figure>
运行结果<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mystaticfunc() 被调用了</span><br></pre></td></tr></table></figure></li>
<li>模板参数的推断   <ul>
<li>隐式推断<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">A</span>(T val1, T val2)</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;A::A(T val1, T val2)执行了&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
main中插入<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编译器根据参数，推断出类A&lt;int&gt;，进行推断后的代码：A&lt;int&gt; aobj1(15, 16) </span></span><br><span class="line"><span class="function">A <span class="title">aobj1</span><span class="params">(<span class="number">15</span>, <span class="number">16</span>)</span></span>;</span><br></pre></td></tr></table></figure>
结果<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A::A(T val1, T val2)执行了</span><br></pre></td></tr></table></figure>
推断指南的存在意义是为了让编译器推断出模板参数的类型，如<code>A* aobj3=NULL</code>是非法的，可以写成如下形式<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt;</span></span><br><span class="line"><span class="function"><span class="title">A</span><span class="params">(T, T)</span> -&gt; A&lt;<span class="type">double</span>&gt;</span>;</span><br></pre></td></tr></table></figure>
那么代码<code>A aobj(15, 16);</code>类型推断后就会变成<code>A&lt;double&gt; aobj1(15, 16)</code></li>
<li>自定义的推断<br>  让代码编写者按照自己的方式进行推断类型，不进行隐式推断  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt;</span></span><br><span class="line"><span class="function"><span class="title">A</span><span class="params">(T)</span> -&gt; A&lt;T&gt;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//有上代码</span></span></span><br><span class="line"><span class="function">A <span class="title">aobj2</span><span class="params">(<span class="number">12.8</span>)</span></span>; <span class="comment">//有类型推断后相当于A&lt;double&gt; aboj2(12.8)</span></span><br></pre></td></tr></table></figure>
  例子：  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">  T m_b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">B&lt;<span class="type">int</span>&gt; bobj1;</span><br><span class="line">B&lt;<span class="type">int</span>&gt; bobj2&#123;<span class="number">15</span>&#125;;</span><br><span class="line"></span><br><span class="line">B bobj3&#123;<span class="number">15</span>&#125;; <span class="comment">//语法错误 无法推断出bobj3具体类型</span></span><br></pre></td></tr></table></figure>
  针对上错误可以添加一个自定义推断指南  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="title">B</span><span class="params">(T)</span> -&gt; B&lt;T&gt;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="类模板的特化"><a href="#类模板的特化" class="headerlink" title="类模板的特化"></a>类模板的特化</h3><p>开始示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TC</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">TC</span>()</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;TC的泛化版本构造函数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">functest1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;functest1泛化版本&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//mian中添加如下代码</span></span><br><span class="line">TC&lt;<span class="type">int</span>, <span class="type">float</span>&gt; mytc;</span><br><span class="line">mytc.<span class="built_in">functest1</span>();</span><br></pre></td></tr></table></figure>
<p>结果显示</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">TC的泛化版本构造函数</span><br><span class="line">functest1泛化版本</span><br></pre></td></tr></table></figure>
<p>特化的版本是是在泛化的类模板上生成的，先有泛化版本才有特化版本</p>
<ul>
<li>类模板的全特化<br>所谓全特化就是将模板参数全用具体类型指代<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TC</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">TC</span>()</span><br><span class="line">    &#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;TC&lt;int, int&gt;特化版本构造函数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main中添加如下代码</span></span><br><span class="line">TC&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mytc2;</span><br><span class="line">mytc<span class="number">2.f</span>unctest1();</span><br></pre></td></tr></table></figure>
以上会编译报错，因为需要针对特化版本functest1的成员函数进行定义<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TC</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">TC</span>()</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;TC&lt;int, int&gt;特化版本构造函数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">functest1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;functest1特化版本执行了&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">再进行编译，就可以通过了</span><br></pre></td></tr></table></figure>
结果<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TC&lt;int, int&gt;特化版本构造函数</span><br><span class="line">functest1特化版本执行了</span><br></pre></td></tr></table></figure>
对functest1函数在类外编写<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//template&lt;&gt; 这一行不用编写，否则语法报错</span></span><br><span class="line"><span class="type">void</span> TC&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::<span class="built_in">functest1</span>()</span><br><span class="line">&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;functest1泛化版本&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
因为类模板已经全特化，这相当于一个普通类，所以要按照一个普通类的草原函数的实现方法来写</li>
<li>普通成员函数的的全特化    <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">void</span> TC&lt;<span class="type">double</span>, <span class="type">int</span>&gt;::<span class="built_in">functest1</span>()</span><br><span class="line">&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;特化TC&lt;double, int&gt;::functest1() 执行了&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main中添加代码</span></span><br><span class="line">TC&lt;<span class="type">double</span>, <span class="type">int</span>&gt; mytc3;</span><br><span class="line">mytc<span class="number">3.f</span>unctest1();</span><br></pre></td></tr></table></figure>
运行结果<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">TC的泛化版本构造函数</span><br><span class="line">特化TC&lt;double, int&gt;::functest1() 执行了</span><br></pre></td></tr></table></figure></li>
<li>静态成员变量的全特化<br>先在TC类泛化版本中声明静态成员变量<code>static int m_stc;</code><br>然后在类外定义<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="type">int</span> TC&lt;T, U&gt;::m_stc = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在main中添加如下代码</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;mytc3.m_stc = &quot;</span> &lt;&lt; mytc<span class="number">3.</span>m_stc &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
结果<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mytc3.m_stc = 50</span><br></pre></td></tr></table></figure>
对静态成员变量进行全特化<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">int</span> TC&lt;<span class="type">double</span>, <span class="type">int</span>&gt;::m_stc = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在main中添加如下代码</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;mytc3.m_stc = &quot;</span> &lt;&lt; mytc<span class="number">3.</span>m_stc &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
结果<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mytc3.m_stc = 100</span><br></pre></td></tr></table></figure></li>
<li>类模板的偏特化（局部特化）<br>模板参数数量上的偏特化，模板参数范围上的偏特化<ol>
<li>模板参数数量上的偏特化    <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TC</span>&lt;<span class="type">float</span>, U&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">TC</span>()</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;TC&lt;float, U&gt; 偏特化构造函数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">functest1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="type">void</span> TC&lt;<span class="type">float</span>, U&gt;::<span class="built_in">functest1</span>()</span><br><span class="line">&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;TC&lt;float, U&gt;::functest1() 偏特化版本执行了&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main中添加如下代码</span></span><br><span class="line">TC&lt;<span class="type">float</span>, <span class="type">int</span>&gt; mytc4;</span><br><span class="line">mytc<span class="number">4.f</span>unctest1();</span><br></pre></td></tr></table></figure>
 结果 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">TC&lt;float, U&gt; 偏特化构造函数</span><br><span class="line">TC&lt;float, U&gt;::functest1() 偏特化版本执行了</span><br></pre></td></tr></table></figure></li>
<li>模板参数范围上的偏特化    <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TC</span>&lt;<span class="type">const</span> T, U*&gt;</span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">TC</span>()</span><br><span class="line"> &#123;</span><br><span class="line">   std::cout &lt;&lt; <span class="string">&quot;TC&lt;const T, U*&gt; 偏特化版本构造函数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">functest1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="type">void</span> TC&lt;<span class="type">const</span> T, U*&gt;::<span class="built_in">functest1</span>()</span><br><span class="line">&#123;</span><br><span class="line"> std::cout &lt;&lt; <span class="string">&quot;TC&lt;const T, U*&gt;::functest1() 执行了&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在main中添加如下代码</span></span><br><span class="line">TC&lt;<span class="type">const</span> <span class="type">float</span>, <span class="type">int</span> *&gt; mytc5;</span><br><span class="line">mytc<span class="number">5.f</span>unctest1();</span><br></pre></td></tr></table></figure>
结果<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">TC&lt;const T, U*&gt; 偏特化版本构造函数</span><br><span class="line">TC&lt;const T, U*&gt;::functest1() 执行了</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><ul>
<li>常规默认参数<br>类型模板默认参数有一个规矩：如果某个模板参数有默认值，那么从这个有默认值的模板参数开始，后面所有的模板参数都得要有默认值<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T=<span class="type">char</span>, <span class="keyword">typename</span> U=<span class="type">int</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> TC</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mian中可添加如下代码</span></span><br><span class="line">TC&lt;&gt; mytc5;</span><br><span class="line">TC&lt;<span class="type">double</span>&gt; mytc6; </span><br></pre></td></tr></table></figure>
偏特化版本中可以不用有默认值，以下代码编译会报错<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T=<span class="type">char</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> TC&lt;T, <span class="type">int</span>&gt;&#123;&#125;;</span><br></pre></td></tr></table></figure></li>
<li>后面模板参数依赖前模板参数<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U=T*&gt;</span><br><span class="line"><span class="keyword">struct</span> TC&#123;&#125;;</span><br></pre></td></tr></table></figure></li>
<li>在模板中声明指定默认参数<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U, <span class="keyword">typename</span> V=<span class="type">int</span>, <span class="keyword">typename</span> W=<span class="type">char</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> TC;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><ul>
<li>typedef写法<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> TC&lt;<span class="type">int</span>, <span class="type">float</span>&gt; IF_TC;</span><br><span class="line">IF_TC mytc10;</span><br></pre></td></tr></table></figure></li>
<li>using写法<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> IF_TCU = TC&lt;<span class="type">int</span>, <span class="type">float</span>&gt;;</span><br><span class="line">IF_TCU mytc11;</span><br></pre></td></tr></table></figure>
推荐使用using模式</li>
</ul>
<h3 id="非类型模板参数"><a href="#非类型模板参数" class="headerlink" title="非类型模板参数"></a>非类型模板参数</h3><p>模板参数不但可以是一个类型，也可以是一个普通的参数，当然参数也可以给一个默认值   </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U, <span class="type">size_t</span> arr_size=<span class="number">8</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> TC</span><br><span class="line">&#123;</span><br><span class="line">  T m_arr[arr_size];</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">functest2</span><span class="params">()</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// functest2定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U, <span class="type">size_t</span> arr_size&gt;</span><br><span class="line"><span class="type">void</span> TC&lt;T, U, arr_size&gt;::<span class="built_in">functest2</span>()</span><br><span class="line">&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;functest2 泛化版本&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在main中插入如下代码</span></span><br><span class="line">TC&lt;<span class="type">double</span>, <span class="type">double</span>&gt; mytc30;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">size_t</span> i=<span class="number">0</span>; i&lt;<span class="number">8</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">  mytc<span class="number">30.</span>m_arr[i] = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样，如果将size_t替换为auto也是可以的，不过非类型模板参数有一些限制（常量，类型一般限制在整型、指针类型）</p>
<ol>
<li>全局指针不能作为模板参数     <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">const</span> <span class="type">char</span> *p&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TC2</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">TC2</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* g_s = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main中插入如下代码 </span></span><br><span class="line">TC2&lt;g_s&gt; mytc40; <span class="comment">//编译报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 把g_s修改以下定义就可以正常编译</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> g_s[] = <span class="string">&quot;hello&quot;</span>;</span><br></pre></td></tr></table></figure></li>
<li>字符串常量也无法作为模板参数     <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">TC2&lt;<span class="string">&quot;hello&quot;</span>&gt; mytc41;</span><br><span class="line"><span class="comment">//编译报错提示 模板参数的表达式无效</span></span><br></pre></td></tr></table></figure></li>
<li>float、double这样的浮点数不允许作为非类型模板参数，应为这两个数都是不精确的</li>
</ol>
<h3 id="成员函数模板"><a href="#成员函数模板" class="headerlink" title="成员函数模板"></a>成员函数模板</h3><ul>
<li>基本含义、构造函数模板<br>不管普通类还是类模板，都可以为其定义成员模板函数<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function">  <span class="title">A</span><span class="params">(T2 v1, T2 v2)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T3&gt;</span></span><br><span class="line"><span class="function">  <span class="type">void</span> <span class="title">myft</span><span class="params">(T3 tmpt)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; tmpt &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">  T1 m_ic;</span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> m_stcvalue = <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类外实现模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1&gt;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T2&gt;</span><br><span class="line">A&lt;T1&gt;::<span class="built_in">A</span>(T2 v1, T2 v2)</span><br><span class="line">&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;A::A(T2, T2)执行了&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>拷贝构造函数模板与拷贝赋值运算符模板<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 拷贝构造模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function"><span class="title">A</span><span class="params">(<span class="type">const</span> A&lt;U&gt;&amp; other)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;A::A(const A&lt;U&gt;&amp; other) 拷贝构造函数模板执行了&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拷贝赋值运算符模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">A&lt;T1&gt;&amp; <span class="keyword">operator</span> = (<span class="type">const</span> A&lt;U&gt;&amp; other)</span><br><span class="line">&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;operator=(const A&lt;U&gt;&amp; other) 拷贝赋值运算符执行了&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
注意点:<ul>
<li>拷贝构造函数模板不是拷贝构造函数，拷贝赋值运算符模板不是拷贝赋值运算符。因为拷贝构造函数或拷贝赋值运算符要求拷贝的对象类型完全相同，而拷贝构造函数&#x2F;运算符的模板没这种要求</li>
</ul>
</li>
<li>特化<br>类模板定义中插入如下代码<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T3, <span class="keyword">typename</span> T4&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myft</span><span class="params">(T3 tmp1, T4 tmp2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;myft() 泛化版本&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T4&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myft</span><span class="params">(<span class="type">int</span> tmp1, T4 tmp2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;myft() 偏特化版本&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myft</span><span class="params">(<span class="type">int</span> tmp1, <span class="type">int</span> tmp2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;myft() 全特化版本&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
类外编写<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1&gt;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T4&gt;</span><br><span class="line"><span class="type">void</span> A&lt;T1&gt;::<span class="built_in">myft</span>(<span class="type">int</span> tmp1, T4 tmp2)</span><br><span class="line">&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;myft() 偏特化版本&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//全特化版本编译会出错 c++标准不允许类模板之外全特化一个未被特化的类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1&gt;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">void</span> A&lt;T1&gt;::<span class="built_in">myft</span>(<span class="type">int</span> tmp1, <span class="type">int</span> tmp2)</span><br><span class="line">&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;myft() 全特化版本&quot;</span>&lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对于以上全特化类外编写可以全特化一个类模板A</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&lt;<span class="type">float</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T3, <span class="keyword">typename</span> T4&gt;</span></span><br><span class="line"><span class="function">  <span class="type">void</span> <span class="title">myft</span><span class="params">(T3 tmp1, T4 tmp2)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;myft() 泛化版本&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// A&lt;float&gt;中有泛化版本的myft()，因此不用在A&lt;float&gt;中生命如下的全特化版本</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">void</span> A&lt;<span class="type">float</span>&gt;::<span class="built_in">myft</span>(<span class="type">int</span> tmp1, <span class="type">float</span> tmp2)</span><br><span class="line">&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;myft() 全特化版本&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
现实编码中建议将特化版卸载模板类的内部，类模板一般都要写在头文件中</li>
</ul>
<h3 id="类-类模板中的类模板-类模板的嵌套"><a href="#类-类模板中的类模板-类模板的嵌套" class="headerlink" title="类&#x2F;类模板中的类模板(类模板的嵌套)"></a>类&#x2F;类模板中的类模板(类模板的嵌套)</h3><p>在类模板A<float>全特化插入如下代码，示例：      </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">OtherC</span></span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">myfOC</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;myfOC 执行了&quot;</span> &lt;&lt; std::endl; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="comment">/************************************************/</span></span><br><span class="line"><span class="comment">//类外定义myfOC()</span></span><br><span class="line"><span class="comment">// template&lt;&gt; 这一行可以不用添加 A&lt;float&gt;当成一个正常的类来看待</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="type">void</span> A&lt;<span class="type">float</span>&gt;::OtherC&lt;U&gt;::<span class="built_in">myfOC</span>()</span><br><span class="line">&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;myfOC 执行了&quot;</span> &lt;&lt; std::endl; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************/</span></span><br><span class="line"><span class="comment">// 在main中插入如下代码</span></span><br><span class="line">A&lt;<span class="type">float</span>&gt;::OtherC&lt;<span class="type">float</span>&gt; myobjc;</span><br><span class="line">myobjc.<span class="built_in">myfOC</span>();</span><br></pre></td></tr></table></figure>
<p>执行结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">myfOC 执行了</span><br></pre></td></tr></table></figure>
<p>如果myfOC插入了泛化版本,类外实现版本如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1&gt;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="type">void</span> A&lt;T1&gt;::Other&lt;U&gt;::<span class="built_in">myfOC</span>()</span><br><span class="line">&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;myfOC 执行了&quot;</span> &lt;&lt; std::endl; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="变量模板与成员变量模板"><a href="#变量模板与成员变量模板" class="headerlink" title="变量模板与成员变量模板"></a>变量模板与成员变量模板</h3><p>变量模板Variable Templates,C++14标准引入。一般定义在全局空间或命名空间中（.h文件内）<br>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T g_myvar&#123;&#125;; <span class="comment">// &#123;&#125;代表零初始化 bool:false number:0  point:nullptr。如不进行零初始化，局部变量随机</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>变量模板的特化<ol>
<li>变量模板的全特化 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T g_myvar&#123;&#125;;</span><br><span class="line"><span class="comment">// 针对变量模板g_myvar特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">char</span> g_myvar&lt;<span class="type">double</span>&gt;&#123;&#125;;  <span class="comment">//针对此类模板特化时，并不需要考虑特化类型double与这个变量模板类型char一致</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// main中插入如下代码</span></span><br><span class="line">g_myvar&lt;<span class="type">double</span>&gt; = <span class="string">&#x27;2&#x27;</span>; <span class="comment">// 其存储的变量是char类型，值为‘2’</span></span><br></pre></td></tr></table></figure></li>
<li>变量模板的偏特化 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T g_myvar&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//特化版本</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T g_myvar&lt;T *&gt;&#123;<span class="number">120</span>&#125;; <span class="comment">//T 表示模板类型， T * 表示正在特化的类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// main中插入如下代码</span></span><br><span class="line">std::cout &lt;&lt; g_myvar&lt;<span class="type">int</span> *&gt; &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; g_myvar&lt;<span class="type">int</span>&gt; &lt;&lt; std::endl; </span><br></pre></td></tr></table></figure>
 结果 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">120</span><br><span class="line">0</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>默认模板参数<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T=<span class="type">int</span>&gt;</span><br><span class="line">T g_myvar;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main中插入如下代码</span></span><br><span class="line">g_myvar&lt;<span class="type">int</span>&gt; = <span class="number">13</span>;</span><br><span class="line">g_myvar&lt;&gt; = <span class="number">26</span>; <span class="comment">// g_myvar&lt;int&gt; 等价于g_myvar，最后g_myvar&lt;int&gt;的值为26;</span></span><br></pre></td></tr></table></figure></li>
<li>非类型模板参数<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">int</span> value&gt;</span><br><span class="line">T g_myvar3[value];</span><br><span class="line"></span><br><span class="line"><span class="comment">// main中插入如下代码</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">15</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">  g_myvar&lt;<span class="type">int</span>, <span class="number">15</span>&gt;[i] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>变量模板的另一种形式<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">static</span> T value = &#123;<span class="number">160</span>&#125;; <span class="comment">//const 也可以写成constexpr,&#123;&#125;可以不加</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> g_myvar4 = B&lt;T&gt;::value; <span class="comment">// 注意g_myvar4是个变量模板</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// main中插入如下代码</span></span><br><span class="line">std::cout &lt;&lt; g_myvar4&lt;<span class="type">int</span>&gt; &lt;&lt; std::endl; <span class="comment">//160</span></span><br><span class="line">g_myvar4&lt;<span class="type">int</span>&gt; = <span class="number">152</span>;</span><br><span class="line">std::cout &lt;&lt; g_myvar4&lt;<span class="type">int</span>&gt; &lt;&lt; std::endl; <span class="comment">//152</span></span><br><span class="line">std::cout &lt;&lt; B&lt;<span class="type">int</span>&gt;::value &lt;&lt; std::endl; <span class="comment">// 160 value值不发生变化</span></span><br></pre></td></tr></table></figure></li>
<li>成员变量模板<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> W&gt;</span><br><span class="line">  <span class="type">static</span> W m_tpi; <span class="comment">//静态成员变量模板声明</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类外定义静态成员变量</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> W&gt;</span><br><span class="line">W D&lt;T&gt;::m_tpi = <span class="number">5</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="别名模板与成员别名模板"><a href="#别名模板与成员别名模板" class="headerlink" title="别名模板与成员别名模板"></a>别名模板与成员别名模板</h3><p>别名模板Alias Templates C++11标准引入，引入目的是为了简化书写，示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="type">str_map_t</span> = std::map&lt;std::string, T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main 中插入</span></span><br><span class="line"><span class="type">str_map_t</span>&lt;<span class="type">int</span>&gt; map1;</span><br><span class="line">map<span class="number">1.</span><span class="built_in">insert</span>(&#123;<span class="string">&quot;first&quot;</span>, <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>也可以放在类或者类模板中</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">E</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="keyword">using</span> <span class="type">str_map_t</span> = std::map&lt;std::string, T&gt;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">str_map_t</span>&lt;<span class="type">int</span>&gt; map1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main 中插入</span></span><br><span class="line">E&lt;<span class="type">float</span>&gt; obja;</span><br><span class="line">obja.map<span class="number">1.</span><span class="built_in">insert</span>(&#123;<span class="string">&quot;first&quot;</span>, <span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="模板模板参数"><a href="#模板模板参数" class="headerlink" title="模板模板参数"></a>模板模板参数</h3><p>模板模板参数 Template Template Parmeters, 意思是让模板参数本身从未模板，如<code>myclass&lt;int, vector&gt;</code><br>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误示范</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Container = std::vector&gt;</span><br><span class="line"><span class="keyword">class</span> myclass</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Container&lt;T&gt; myc;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为Container 是类型模板参数，不是模板模板参数，所以要告诉编译器Container是模板模板参数</span></span><br><span class="line"><span class="keyword">template</span>&lt;</span><br><span class="line">  <span class="keyword">typename</span> T, </span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">class</span>&gt; <span class="keyword">class</span> <span class="title class_">Container</span> = std::vector</span><br><span class="line">&gt;</span><br><span class="line"><span class="keyword">class</span> myclass</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Container&lt;T&gt; myc;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**************************/</span></span><br><span class="line"><span class="comment">// 也可以有如下写法</span></span><br><span class="line"><span class="keyword">template</span>&lt;</span><br><span class="line">  <span class="keyword">template</span> T,</span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> W&gt; <span class="keyword">typename</span> Container = std::vector</span><br><span class="line">&gt;</span><br><span class="line"><span class="keyword">class</span> myclass</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Container&lt;T&gt; myc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>特别声明：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 上述代码中W看成是Container的类型模板参数，W无论如何也是是用不到的，也不能在类中使用，通常省略。</span></span><br><span class="line"><span class="keyword">template</span>&lt;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">template</span>&lt;typenameW, W* point&gt; <span class="keyword">typename</span> Container</span><br><span class="line">&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myclass2</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//W *m_p 此处报错</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另外如果类模板中不是Container也可以将其省略，于是出现如下写法</span></span><br><span class="line"><span class="keyword">template</span>&lt;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt; <span class="keyword">typename</span> = std::vector</span><br><span class="line">&gt;</span><br><span class="line"><span class="keyword">class</span> myclass3</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="共用体模板-联合模板"><a href="#共用体模板-联合模板" class="headerlink" title="共用体模板(联合模板)"></a>共用体模板(联合模板)</h3><p>与结构体很相似，只不过共用体是把几种不同类型的变量存放到一段内存单元。 Union Templates<br>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">union</span> <span class="title class_">myuni</span></span><br><span class="line">&#123;</span><br><span class="line">  T carnum;</span><br><span class="line">  U cartype;</span><br><span class="line">  U cname[<span class="number">60</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main 中插入</span></span><br><span class="line">myuni&lt;<span class="type">int</span>,<span class="type">char</span>&gt; myu;</span><br><span class="line">myu.carnum = <span class="number">156</span>;</span><br><span class="line">std::cout &lt;&lt; myu.carnum &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">156</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++泛型</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt6_Charts_01</title>
    <url>/Lei_Blog/2024/11/07/Qt6-Charts-01/</url>
    <content><![CDATA[<h2 id="基本图表绘制"><a href="#基本图表绘制" class="headerlink" title="基本图表绘制"></a>基本图表绘制</h2><h3 id="配置设置"><a href="#配置设置" class="headerlink" title="配置设置"></a>配置设置</h3><p>cmake配置</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在配置中寻找关于chart的模块</span></span><br><span class="line"><span class="keyword">find_package</span>(Qt<span class="variable">$&#123;QT_VERSION_MAJOR&#125;</span> COMPONENTS Charts REQUIRED)</span><br><span class="line"><span class="comment"># 然后进行链接</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(QTchart_01 PRIVATE Qt<span class="variable">$&#123;QT_VERSION_MAJOR&#125;</span>::Charts)</span><br></pre></td></tr></table></figure>
<h3 id="QChartView"><a href="#QChartView" class="headerlink" title="QChartView"></a>QChartView</h3><p>QChart类主要是组织图表的内容（文档类），QChartView用于展示图表（视图类）。相当于画板和画板上的图像，两者要相互结合</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QChartView *chartview = <span class="keyword">new</span> <span class="built_in">QChartView</span>(<span class="keyword">this</span>);</span><br><span class="line">QChar *chart = <span class="keyword">new</span> <span class="built_in">QChart</span>();</span><br><span class="line">chart-&gt;<span class="built_in">setTitle</span>(<span class="string">&quot;chat01&quot;</span>);</span><br><span class="line"><span class="comment">// 将chart对象添加于chartview中</span></span><br><span class="line">chartview-&gt;<span class="built_in">setChart</span>(chart);</span><br><span class="line"><span class="comment">// 添加到父窗口中</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setCentralWidget</span>(chartview);</span><br></pre></td></tr></table></figure>
<h3 id="添加数值并绘制"><a href="#添加数值并绘制" class="headerlink" title="添加数值并绘制"></a>添加数值并绘制</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QLineSeries *series1 = <span class="keyword">new</span> <span class="built_in">QLineSeries</span>();</span><br><span class="line">series1-&gt;<span class="built_in">setName</span>(<span class="string">&quot;sin() line&quot;</span>);</span><br><span class="line"></span><br><span class="line">qreal t=<span class="number">0</span>, y1, y2, intv=<span class="number">0.1</span>;</span><br><span class="line"><span class="type">int</span> count = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;count; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    y1 = <span class="built_in">qSin</span>(t);</span><br><span class="line">    <span class="comment">// qDebug() &lt;&lt; y1;</span></span><br><span class="line">    series1-&gt;<span class="built_in">append</span>(t, y1);</span><br><span class="line">    t += intv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">chart-&gt;<span class="built_in">addSeries</span>(series1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建坐标轴</span></span><br><span class="line">QValueAxis *axisX = <span class="keyword">new</span> <span class="built_in">QValueAxis</span>();</span><br><span class="line">QValueAxis *axisY = <span class="keyword">new</span> <span class="built_in">QValueAxis</span>();</span><br><span class="line"><span class="comment">//设置范围</span></span><br><span class="line">axisX-&gt;<span class="built_in">setRange</span>(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">axisX-&gt;<span class="built_in">setTitleText</span>(<span class="string">&quot;x_zhou&quot;</span>);</span><br><span class="line">axisY-&gt;<span class="built_in">setRange</span>(<span class="number">-2</span>, <span class="number">2</span>);</span><br><span class="line">axisY-&gt;<span class="built_in">setTitleText</span>(<span class="string">&quot;value&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//坐标轴添加到图表，并指定方向</span></span><br><span class="line">chart-&gt;<span class="built_in">addAxis</span>(axisX,Qt::AlignBottom);</span><br><span class="line">chart-&gt;<span class="built_in">addAxis</span>(axisY,Qt::AlignLeft);</span><br><span class="line"><span class="comment">//同时将数值序列依附于XY轴</span></span><br><span class="line">series1-&gt;<span class="built_in">attachAxis</span>(axisX);</span><br><span class="line">series1-&gt;<span class="built_in">attachAxis</span>(axisY);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>QT6</category>
      </categories>
      <tags>
        <tag>qt6 chart</tag>
      </tags>
  </entry>
  <entry>
    <title>C++模板与泛型_基础_03</title>
    <url>/Lei_Blog/2024/11/09/C-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B-%E5%9F%BA%E7%A1%80-03/</url>
    <content><![CDATA[<h2 id="类模板中的友元"><a href="#类模板中的友元" class="headerlink" title="类模板中的友元"></a>类模板中的友元</h2><h3 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h3><p>让某个类B成为另外一个类A的友，这样B类就可以访问类A的所有变量和函数</p>
<ul>
<li><p>让类模板某个实例成为友元</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">callBAF</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      A&lt;<span class="type">int</span>&gt; atmpobj;</span><br><span class="line">      atmpobj.data = <span class="number">5</span>;</span><br><span class="line">      std::cout &lt;&lt; atmpobj.data &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// main 中插入</span></span><br><span class="line">B&lt;<span class="type">long</span>&gt; bobj;</span><br><span class="line">bobj.<span class="built_in">callFAF</span>();</span><br></pre></td></tr></table></figure>
<p>但上述代码会报错，因为模板类B<long>，不是A<int>的友元类，在类B中无法访问A<int>中的私有变量,修改如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">B</span>&lt;<span class="type">long</span>&gt;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>做如上修改就可以让B<long>,访问模板类A中的元素了</p>
</li>
<li><p>让类模板成为友元类模板<br>上面仅限于B<long>是模板类A的友元，如何让模板类B也成为A的友元，不限定模板参数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt; <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>做出如上修改就可以实现了</p>
</li>
<li><p>让类模板参数成为友元      </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">friend</span> T;</span><br><span class="line">  <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AF</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">callAFAF</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      A&lt;AF&gt; aobj;</span><br><span class="line">      aobj.data = <span class="number">12</span>;</span><br><span class="line">      std::cout &lt;&lt; aobj.data &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h3><p>函数模板可以被声明为友元函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U, <span class="keyword">typename</span> V&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(U val1, V val2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Men</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U, <span class="keyword">typename</span> V&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">friend</span> <span class="type">void</span> <span class="title">func</span><span class="params">(U val1, V val2)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">funcman</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Men::funcman 被调用了&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U, <span class="keyword">typename</span> V&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(U val1, V val2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Men mymen;</span><br><span class="line">    mymen.<span class="built_in">funcman</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>让函数模板的某个实例成为友元函数<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Men</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">void</span> <span class="built_in">func</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="type">int</span> val1, <span class="type">int</span> val2);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">funcman</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Men::funcman 被调用了&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>在类模板中定义友元函数<br>这种写法会比较奇怪，友元函数可以在类外调用，虽然写在类模板中，但应看作全局函数<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Z&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Men</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">func</span><span class="params">(Men&lt;Z&gt; &amp;tmpmen)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      tmpmen.<span class="built_in">funcmen</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main中插入代码</span></span><br><span class="line">Men&lt;<span class="type">double</span>&gt; mynen1;</span><br><span class="line"><span class="built_in">func</span>(mynen2);</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++泛型</tag>
      </tags>
  </entry>
  <entry>
    <title>C++模板与泛型_基础_04</title>
    <url>/Lei_Blog/2024/11/11/C-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B-%E5%9F%BA%E7%A1%80-04/</url>
    <content><![CDATA[<h3 id="可变参数模板"><a href="#可变参数模板" class="headerlink" title="可变参数模板"></a>可变参数模板</h3><h3 id="可变函数模板"><a href="#可变函数模板" class="headerlink" title="可变函数模板"></a>可变函数模板</h3><ul>
<li>基本含义<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... T &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myvtfunc</span><span class="params">(T... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;--------------begin-------------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="keyword">sizeof</span>...(args) &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="keyword">sizeof</span>...(T) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;--------------end---------------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mian 中插入</span></span><br><span class="line"><span class="built_in">myvtfunc</span>();</span><br><span class="line"><span class="built_in">myvtfunc</span>(<span class="number">10</span>, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line"><span class="built_in">myvtfunc</span>&lt;<span class="type">double</span>, <span class="type">int</span>&gt;(<span class="number">10</span>, <span class="number">25</span>, <span class="string">&quot;abc&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">--------------begin-------------------</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">--------------end---------------------</span><br><span class="line">--------------begin-------------------</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">--------------end---------------------</span><br><span class="line">--------------begin-------------------</span><br><span class="line">4</span><br><span class="line">4</span><br><span class="line">--------------end---------------------</span><br></pre></td></tr></table></figure>
<ul>
<li>typename后面带了三个点，然后修饰T</li>
<li>T后面带了…，T称可变参数类型</li>
</ul>
</li>
<li>参数包的展开<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加一个递归终止函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myvtfunct</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;终止函数执行&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... U&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myvtfunct</span><span class="params">(T firstarg, U ...otherargs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;收到的值为：&quot;</span> &lt;&lt; firstarg &lt;&lt; std::endl;</span><br><span class="line">  <span class="built_in">myvtfunct</span>(otherargs...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main中插入</span></span><br><span class="line"><span class="built_in">myvtfunct</span>(<span class="number">10</span>, <span class="string">&quot;abc&quot;</span>, <span class="number">10.5</span>, <span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">收到的值为：10</span><br><span class="line">收到的值为：abc</span><br><span class="line">收到的值为：10.5</span><br><span class="line">收到的值为：a</span><br><span class="line">终止函数执行</span><br></pre></td></tr></table></figure>
c++17标准的另外一种写法<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>...U&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myvtfunc</span><span class="params">(T firstarg, U ...otherargs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;收到的参数值为：&quot;</span> &lt;&lt; firstarg &lt;&lt; std::endl;</span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span><span class="params">(<span class="keyword">sizeof</span>...(otherargs) &gt; <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">myvtfunct</span>(otherargs...);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//什么也不做</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>重载<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myfunc</span><span class="params">(T... arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;myfunc(T.. arg)执行了&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myfunc</span><span class="params">(T*... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;myfunc(T*... args)执行了&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myfunc</span><span class="params">(<span class="type">int</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;myfunc(int arg)执行了&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main中插入</span></span><br><span class="line"><span class="built_in">myfunc</span>(<span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">myfunc</span>(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">myfunc</span>((<span class="type">int</span>*)<span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">myfunc(T.. arg)执行了</span><br><span class="line">myfunc(T.. arg)执行了</span><br><span class="line">myfunc(T*... args)执行了</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="折叠表达式"><a href="#折叠表达式" class="headerlink" title="折叠表达式"></a>折叠表达式</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add_val</span><span class="params">(T... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (... + args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main中插入</span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">add_val</span>(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>) &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">60</span><br></pre></td></tr></table></figure>
<ul>
<li>一元左折与一元右折<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一元左折（（（参数1 运算符 参数2）运算符 参数3）...运算符 参数N）</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sub_val_left</span><span class="params">(T... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (... - args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 亿元右折 （参数1 运算符（...（参数N-1 运算符 参数N）））</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sub_val_right</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (args - ...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main中插入</span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">sub_val_left</span>(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>) &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">/// 10-20-30-40</span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">sub_val_right</span>(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>) &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">// 10-(20-(30-40))</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-80</span><br><span class="line">-20</span><br></pre></td></tr></table></figure></li>
<li>二元左折与二元右折<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sub_value_left_b</span><span class="params">(T ... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="number">220</span> - ... - args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sub_value_right_b</span><span class="params">(T ... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (args - ... <span class="number">-220</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main中插入</span></span><br><span class="line"><span class="comment">// ((220 - 10) - 20) - 30</span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">sub_value_left_b</span>(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>) &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">// (10 - (20 - (30 - 220)))</span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">sub_value_right_b</span>(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>) &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="可变参表达式"><a href="#可变参表达式" class="headerlink" title="可变参表达式"></a>可变参表达式</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">print_result</span><span class="params">(T <span class="type">const</span>&amp; ... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  (std::cout &lt;&lt; ... &lt;&lt; args) &lt;&lt; <span class="string">&quot; 结束&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> (... + args); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main中插入</span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">print_result</span>(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>) &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">102030 结束</span><br><span class="line">60</span><br></pre></td></tr></table></figure>
<p>带参数版本</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_calc</span><span class="params">(T <span class="type">const</span>&amp; ... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  </span><br><span class="line">  std::cout &lt;&lt; <span class="built_in">print_result</span>(<span class="number">2</span>* args...) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main中插入 内部函数等价于 print_result(20, 40, 60)</span></span><br><span class="line"><span class="built_in">print_calc</span>(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">204060</span><br><span class="line">120</span><br></pre></td></tr></table></figure>
<p>注意：数字与 … 之间要有空格隔开</p>
<h3 id="可变参类模板"><a href="#可变参类模板" class="headerlink" title="可变参类模板"></a>可变参类模板</h3><ul>
<li>通过递归继承方式展开类型、非类型、模板模板参数包<ol>
<li>类型模板参数包的展开 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> First, <span class="keyword">typename</span>... Others&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myclasst</span>&lt;First, Others...&gt; : <span class="keyword">private</span> myclasst&lt;Others&gt; </span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...Args&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myclasst</span></span><br><span class="line">&#123; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
 偏特化 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Others&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myclasst</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> First, <span class="keyword">typename</span>... Others&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myclasst</span>&lt;First, Others...&gt; : <span class="keyword">private</span> myclasst&lt;Others...&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">myclasst</span>():<span class="built_in">m_i</span>(<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;myclasst::myclasst() 偏特化版本执行了this position: &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot; sizeof...(Others): &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>...(Others) &lt;&lt; std::endl; </span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  First m_i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 主模板</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Others&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myclasst</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">myclasst</span>()</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;myclast:;myclasst() 泛化版本执行了，this position: &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// mian中插入</span></span><br><span class="line">myclasst&lt;<span class="type">int</span>, <span class="type">float</span>, <span class="type">double</span>&gt; myc;</span><br></pre></td></tr></table></figure>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">myclast:;myclasst() 泛化版本执行了，this position: 0x7fff587587a0</span><br><span class="line">myclasst::myclasst() 偏特化版本执行了this position: 0x7fff587587a0 sizeof...(Others): 0</span><br><span class="line">myclasst::myclasst() 偏特化版本执行了this position: 0x7fff587587a0 sizeof...(Others): 1</span><br><span class="line">myclasst::myclasst() 偏特化版本执行了this position: 0x7fff587587a0 sizeof...(Others): 2</span><br></pre></td></tr></table></figure>
 需要注意的点<ul>
<li>带3个点的参数不能超过1个</li>
<li>一般带点的参数要放在最后</li>
<li>上两点对对参数特化不适用</li>
</ul>
</li>
<li>非类型模板参数包的展开 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span>... Args&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myclasst</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">myclasst</span>()</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;myclast::myclasst() 泛化版本执行了 this pos: &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> First, <span class="type">int</span>... Others&gt; <span class="comment">/// int 换成auto也可以</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myclasst</span>&lt;First, Others...&gt; : <span class="keyword">private</span> myclasst&lt;Others...&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">myclasst</span>()</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;myclasst::myclast() 偏特化版本执行了 this pos: &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot; sizeof...(Others): &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>...(Others) &lt;&lt; <span class="string">&quot;   First is &quot;</span>&lt;&lt; First &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main中插入</span></span><br><span class="line">myclasst&lt;<span class="number">12</span>, <span class="number">18</span>, <span class="number">23</span>&gt; myt;</span><br></pre></td></tr></table></figure>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">myclast::myclasst() 泛化版本执行了 this pos: 0x7ffc139d54e7</span><br><span class="line">myclasst::myclast() 偏特化版本执行了 this pos: 0x7ffc139d54e7 sizeof...(Others): 0   First is 23</span><br><span class="line">myclasst::myclast() 偏特化版本执行了 this pos: 0x7ffc139d54e7 sizeof...(Others): 1   First is 18</span><br><span class="line">myclasst::myclast() 偏特化版本执行了 this pos: 0x7ffc139d54e7 sizeof...(Others): 2   First is 12</span><br></pre></td></tr></table></figure></li>
<li>模板模板参数包的展开   <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,</span><br><span class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt; <span class="keyword">typename</span>... Container</span><br><span class="line">&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ParentMM</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">ParentMM</span>()</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ParentMM::ParentMM()执行了，this = &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;</span><br><span class="line">  <span class="keyword">typename</span> T,</span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt; <span class="keyword">typename</span> FirstContainer, <span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt; <span class="keyword">typename</span>... OtherContainers</span><br><span class="line">&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ParentMM</span>&lt;T, FirstContainer, OtherContainers...&gt; : <span class="keyword">private</span> ParentMM&lt;T, OtherContainers...&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">ParentMM</span>()</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ParentMM::ParentMM()偏特化执行了，this=&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot;  sizeof...(OtherContainers):&quot;</span> &lt;&lt; <span class="keyword">sizeof</span>...(OtherContainers) &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  FirstContainer&lt;T&gt; m_container;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;</span><br><span class="line">  <span class="keyword">typename</span> T, </span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt; <span class="keyword">typename</span>... Container</span><br><span class="line">&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myclass</span> : <span class="keyword">private</span> ParentMM&lt;T, Container...&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">myclass</span>()</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;mycalss::myclass() 执行了 this = &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot;  sizeof...(Container): &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>...(Container) &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main中插入</span></span><br><span class="line">myclass&lt;<span class="type">int</span>, std::vector, std::list, std::deque&gt; myc;</span><br></pre></td></tr></table></figure>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ParentMM::ParentMM()执行了，this = 0x7ffe4dace040</span><br><span class="line">ParentMM::ParentMM()偏特化执行了，this=0x7ffe4dace040  sizeof...(OtherContainers):0</span><br><span class="line">ParentMM::ParentMM()偏特化执行了，this=0x7ffe4dace040  sizeof...(OtherContainers):1</span><br><span class="line">ParentMM::ParentMM()偏特化执行了，this=0x7ffe4dace040  sizeof...(OtherContainers):2</span><br><span class="line">mycalss::myclass() 执行了 this = 0x7ffe4dace040  sizeof...(Container): 3</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>通过递归组合方式展开参数包<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...args&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myclass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">myclass</span>()</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;myclass::myclass()泛化版本执行了，this=&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> First, <span class="keyword">typename</span>... Others&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myclass</span>&lt;First, Others...&gt;<span class="comment">//: private myclass&lt;Others...&gt; 偏特化</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">myclass</span>(): <span class="built_in">m_i</span>(<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;myclass::myclass()偏特化版本执行了，this=&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot;  sizeof...(Other):&quot;</span>&lt;&lt;<span class="keyword">sizeof</span>...(Others)&lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 注意第二个参数，这是一个包的写法</span></span><br><span class="line">  <span class="built_in">myclass</span>(First partf, Others... paro):<span class="built_in">m_i</span>(partf), <span class="built_in">m_o</span>(paro...)</span><br><span class="line">  <span class="comment">//, myclass&lt;Others...&gt;(paro...)</span></span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;-----------------begin-------------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;myclass::myclass(First partf, Others... paro)执行了，this=&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;m_i = &quot;</span> &lt;&lt; m_i &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;------------------end--------------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  First m_i;</span><br><span class="line">  myclass&lt;Others...&gt; m_o;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myclass</span>&lt;&gt;<span class="comment">// 一个特殊化的版本，看起来像全特化，可变参模板不存在全特化</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">myclass</span>()</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;myclass::myclass()一个特殊化的版本执行了&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main中插入</span></span><br><span class="line"><span class="function">myclass&lt;<span class="type">int</span>, <span class="type">float</span>, <span class="type">double</span>&gt; <span class="title">myc</span><span class="params">(<span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">myclass::myclass()一个特殊化的版本执行了</span><br><span class="line">-----------------begin-------------------</span><br><span class="line">myclass::myclass(First partf, Others... paro)执行了，this=0x7fffae439fe0</span><br><span class="line">m_i = 14</span><br><span class="line">------------------end--------------------</span><br><span class="line">-----------------begin-------------------</span><br><span class="line">myclass::myclass(First partf, Others... paro)执行了，this=0x7fffae439fd8</span><br><span class="line">m_i = 13</span><br><span class="line">------------------end--------------------</span><br><span class="line">-----------------begin-------------------</span><br><span class="line">myclass::myclass(First partf, Others... paro)执行了，this=0x7fffae439fd0</span><br><span class="line">m_i = 12</span><br><span class="line">------------------end--------------------</span><br></pre></td></tr></table></figure></li>
<li>通过元组和递归调用展开参数包<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 元组的概念</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#include&lt;tuple&gt;</span></span><br><span class="line"><span class="comment">std::tuple&lt;float, int, int&gt; mytuple(12.5f, 100, 52);</span></span><br><span class="line"><span class="comment">std::cout &lt;&lt; std::get&lt;0&gt;(mytuple) &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">std::cout &lt;&lt; std::get&lt;2&gt;(mytuple) &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myfunctuple</span><span class="params">(<span class="type">const</span> tuple&lt;T...&gt;&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mian中插入</span></span><br><span class="line"><span class="built_in">myfunctuple</span>(mytuple);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类模板的泛化版本</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> mycount, <span class="type">int</span> mymaxcount, <span class="keyword">typename</span>... T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myclass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">mysfunc</span><span class="params">(<span class="type">const</span> tuple&lt;T...&gt;&amp; t)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>基类参数包的展开</li>
<li>特化</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++泛型</tag>
      </tags>
  </entry>
  <entry>
    <title>c++线程池</title>
    <url>/Lei_Blog/2024/11/11/c-%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<h2 id="functional-bind-lambda"><a href="#functional-bind-lambda" class="headerlink" title="functional bind lambda"></a>functional bind lambda</h2><ul>
<li><p>测试示例1:functional bind</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassFunc</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Func</span><span class="params">(<span class="type">const</span> std::string &amp;s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; s &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> std::string &amp;s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; s &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Func_</span><span class="params">(<span class="type">const</span> std::string &amp;s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; s &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> std::string &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; s &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(Args... arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    (std::cout &lt;&lt; ... &lt;&lt; arg) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint_</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; b &lt;&lt; c &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">callableFunc</span> <span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span> </span>&#123;<span class="keyword">return</span> x/y;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;-----------------------functional-----------------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="function">std::function&lt;<span class="title">void</span><span class="params">(<span class="type">const</span> std::string &amp;)</span>&gt; <span class="title">func_1</span><span class="params">(func)</span></span>;</span><br><span class="line">    <span class="built_in">func_1</span>(<span class="string">&quot;func1&quot;</span>);</span><br><span class="line">    std::function&lt;<span class="type">void</span>(<span class="type">const</span> std::string &amp;)&gt; func_2 = func;</span><br><span class="line">    <span class="built_in">func_2</span>(<span class="string">&quot;func2&quot;</span>);</span><br><span class="line">    <span class="comment">// std::function&lt;void(const std::string &amp;)&gt; func_3(ClassFunc()) 不可以</span></span><br><span class="line"></span><br><span class="line">    std::function&lt;<span class="type">void</span>(<span class="type">const</span> std::string &amp;)&gt; func_3 = <span class="built_in">ClassFunc</span>();</span><br><span class="line">    <span class="built_in">func_3</span>(<span class="string">&quot;func3&quot;</span>);</span><br><span class="line">    <span class="comment">// std::function&lt;void(const std::string &amp;)&gt; func_4(ClassFunc); 不可以 funnction 要包装可调用对象</span></span><br><span class="line">    <span class="comment">// func_4(&quot;Hello&quot;);</span></span><br><span class="line">    <span class="keyword">auto</span> func_lambda = [](<span class="type">const</span> std::string &amp;s)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; s &lt;&lt; std::endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">std::function&lt;<span class="title">void</span><span class="params">(<span class="type">const</span> std::string &amp;)</span>&gt; <span class="title">func_4</span><span class="params">(func_lambda)</span></span>;</span><br><span class="line">    <span class="built_in">func_4</span>(<span class="string">&quot;func4&quot;</span>);</span><br><span class="line">    std::function&lt;<span class="type">void</span>(<span class="type">const</span> std::string &amp;)&gt; func_5 = func_lambda;</span><br><span class="line">    <span class="built_in">func_5</span>(<span class="string">&quot;func5&quot;</span>);</span><br><span class="line"></span><br><span class="line">    std::function&lt;<span class="type">void</span>(<span class="type">const</span> std::string &amp;)&gt; func_6 = ClassFunc::Func;</span><br><span class="line">    <span class="built_in">func_6</span>(<span class="string">&quot;func6&quot;</span>);</span><br><span class="line">    <span class="function">std::function&lt;<span class="title">void</span><span class="params">(<span class="type">const</span> std::string &amp;)</span>&gt; <span class="title">func_7</span><span class="params">(ClassFunc::Func)</span></span>;</span><br><span class="line">    <span class="built_in">func_7</span>(<span class="string">&quot;func7&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ClassFunc cf;</span><br><span class="line">    <span class="function">std::function&lt;<span class="title">void</span><span class="params">(ClassFunc*, <span class="type">const</span> std::string &amp;)</span>&gt; <span class="title">func_8</span><span class="params">(&amp;ClassFunc::Func_)</span></span>;</span><br><span class="line">    <span class="built_in">func_8</span>(&amp;cf, <span class="string">&quot;func8&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;-----------------------functional-----------------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;--------------------------bind--------------------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::function&lt;<span class="type">void</span>()&gt; func_b1 = std::<span class="built_in">bind</span>(func,<span class="string">&quot;func_b1&quot;</span>);</span><br><span class="line">    <span class="built_in">func_b1</span>();</span><br><span class="line">    std::function&lt;<span class="type">void</span>()&gt; func_b2 = std::<span class="built_in">bind</span>(func_1,<span class="string">&quot;func_b2&quot;</span>);</span><br><span class="line">    <span class="built_in">func_b2</span>();</span><br><span class="line">    std::function&lt;<span class="type">void</span>()&gt; func_b3 = std::<span class="built_in">bind</span>(func_2,<span class="string">&quot;func_b3&quot;</span>);</span><br><span class="line">    <span class="built_in">func_b3</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">myPrint</span>(<span class="string">&quot;sss&quot;</span>, <span class="number">1234</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    <span class="keyword">auto</span> NewCallable = std::<span class="built_in">bind</span>(callableFunc, std::placeholders::_1,<span class="number">2</span>);  </span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">NewCallable</span>(<span class="number">10</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">// std::function&lt;void(int, int, int)&gt; func_b3 = std::bind(myPrint&lt;int, int, int&gt;, std::placeholders::_1, 2);</span></span><br><span class="line">    <span class="comment">// auto func_b4 = std::bind(myPrint_, std::placeholders::_1, 3);</span></span><br><span class="line">    <span class="built_in">myPrint_</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;--------------------------bind--------------------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>测试示例2</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> Compare&gt;</span><br><span class="line"><span class="function">Iterator <span class="title">my_find_if</span><span class="params">(Iterator first, Iterator last, Compare comp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; first != last; ++first)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">comp</span>(*first))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Compare, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">_myBind1st</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    _myBind1st(Compare comp, T val) : _comp(comp), <span class="built_in">val</span>(val) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T &amp;second)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _comp(val, second);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Compare _comp;</span><br><span class="line">    T val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Compare, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">_myBind1st&lt;Compare, T&gt; <span class="title">myBind1st</span><span class="params">(Compare comp, <span class="type">const</span> T &amp;val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _myBind1st&lt;Compare, T&gt;(comp, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Container&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showContainer</span><span class="params">(Container &amp;c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typename</span> Container::iterator i = c.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">for</span> (; i != c.<span class="built_in">end</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(<span class="built_in">rand</span>() % <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">showContainer</span>(vec);</span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">showContainer</span>(vec);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;using greater&lt;int&gt;()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// greater&lt;int&gt;() less&lt;int&gt;() 二元函数对象</span></span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    <span class="built_in">showContainer</span>(vec);</span><br><span class="line">    <span class="comment">// 按序插入70到vec中 找到小于70的数，在之前插入</span></span><br><span class="line">    <span class="comment">// 此处需要一个一元函数对象</span></span><br><span class="line">    <span class="keyword">auto</span> it1 = <span class="built_in">find_if</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="built_in">bind2nd</span>(<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;(), <span class="number">80</span>));</span><br><span class="line">    <span class="keyword">if</span> (it1 != vec.<span class="built_in">end</span>())</span><br><span class="line">        vec.<span class="built_in">insert</span>(it1, <span class="number">70</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;insert 70&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">showContainer</span>(vec);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;using my_find_if&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">auto</span> cmp_l = [](<span class="type">int</span> i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">70</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> it2 = <span class="built_in">my_find_if</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [](<span class="type">int</span> i)</span><br><span class="line">                        &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">80</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; &#125;);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;insert 80&quot;</span> &lt;&lt; endl;</span><br><span class="line">    vec.<span class="built_in">insert</span>(it2, <span class="number">80</span>);</span><br><span class="line">    <span class="built_in">showContainer</span>(vec);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot;insert 30&quot; &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// auto it3 = my_find_if(vec.begin(), vec.end(), bind2nd([](int a, int b)</span></span><br><span class="line">    <span class="comment">//                                                       &#123;</span></span><br><span class="line">    <span class="comment">//     if(a&lt;b)</span></span><br><span class="line">    <span class="comment">//         return true;</span></span><br><span class="line">    <span class="comment">//     return false; &#125;, 30));</span></span><br><span class="line">    <span class="comment">// vec.insert(it3, 30);</span></span><br><span class="line">    <span class="comment">// showContainer(vec);</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;insert 20&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// auto it4 = my_find_if(vec.begin(), vec.end(), myBind1st(greater&lt;int&gt;(),20));</span></span><br><span class="line">    <span class="keyword">auto</span> it4 = <span class="built_in">my_find_if</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="built_in">myBind1st</span>([](<span class="type">const</span> <span class="type">int</span> &amp;a, <span class="type">const</span> <span class="type">int</span> &amp;b)</span><br><span class="line">                                                            &#123;</span><br><span class="line">        <span class="keyword">if</span>(a&gt;b)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; &#125;, <span class="number">20</span>));</span><br><span class="line">    vec.<span class="built_in">insert</span>(it4, <span class="number">20</span>);</span><br><span class="line">    <span class="built_in">showContainer</span>(vec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试示例3：</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Ty&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyFunc</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span>... T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyFunc</span>&lt;<span class="built_in">R</span>(T...)&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> PFUNC = <span class="built_in">R</span> (*)(T...);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyFunc</span>(PFUNC f) : _func(f) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">R <span class="title">operator</span><span class="params">()</span><span class="params">(T... Args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _func(Args...);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    PFUNC _func;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> string <span class="title">getStringPrint</span><span class="params">(<span class="type">const</span> string&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="function">MyFunc&lt;<span class="title">int</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>&gt; <span class="title">f</span><span class="params">(sum)</span></span>;</span><br><span class="line">    <span class="built_in">f</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="function">MyFunc&lt;<span class="type">const</span> <span class="title">string</span><span class="params">(<span class="type">const</span> string &amp;)</span>&gt; <span class="title">f2</span><span class="params">(getStringPrint)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> a = <span class="built_in">f2</span>(s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++池结构</tag>
      </tags>
  </entry>
  <entry>
    <title>C++模板与泛型_基础_05</title>
    <url>/Lei_Blog/2024/11/13/C-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B-%E5%9F%BA%E7%A1%80-05/</url>
    <content><![CDATA[<h2 id="多态在模板中应用"><a href="#多态在模板中应用" class="headerlink" title="多态在模板中应用"></a>多态在模板中应用</h2><p>一个简单的例子</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Men</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Men eat&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Women</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Women eat&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eatPerson</span><span class="params">(T&amp; person)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    person.<span class="built_in">eat</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>传统的多台叫做动态多态（运行时多态），要访问虚函数表指针，在层序执行性能上会有一些影响，而在模板中运用在编译时期就确定了调用谁，因此不存在性能问题，这种多态较静态多态</p>
<h2 id="模板的特殊继承关系"><a href="#模板的特殊继承关系" class="headerlink" title="模板的特殊继承关系"></a>模板的特殊继承关系</h2><h3 id="奇异的递归模板模式"><a href="#奇异的递归模板模式" class="headerlink" title="奇异的递归模板模式"></a>奇异的递归模板模式</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived1</span> : <span class="keyword">public</span> Base&lt;Derived1&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">myfunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived1::myfunc() 执行了&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived2</span> : <span class="keyword">public</span> Base&lt;Derived2&lt;T&gt;&gt;</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>在基类中使用派生类对象<br>在Base基类模板中添加一个public修饰的成员函数asDerived();<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">asDerived</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      T&amp; derived = <span class="built_in">static_cast</span>&lt;T&amp;&gt;(*<span class="keyword">this</span>);</span><br><span class="line">      derived.<span class="built_in">myfunc</span>();  <span class="comment">//调用派生类的成员函数</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// main中插入</span></span><br><span class="line">Derived1 myd;</span><br><span class="line">myd.<span class="built_in">asDerived</span>();</span><br></pre></td></tr></table></figure></li>
<li>基于减少派生类中代码的考虑<br>基于代码量的考虑的出发点是尽可能把一些代码挪到基类中去，从而减少派生类代码量<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">shape</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> == (<span class="type">const</span> shape&lt;T&gt;&amp; obj1, <span class="type">const</span> shape&lt;T&gt;&amp; boj2)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="type">const</span> T&amp; objtmp1 = <span class="built_in">static_cast</span>&lt;<span class="type">const</span> T&amp;&gt;(obj1);</span><br><span class="line">      <span class="type">const</span> T&amp; objtmp2 = <span class="built_in">static_cast</span>&lt;<span class="type">const</span> T&amp;&gt;(obj2);</span><br><span class="line">      <span class="keyword">if</span>(!(objtmp1 &lt; objtmp2) &amp;&amp; !(objtmp2 &lt; objtmp1))</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">squere</span> : <span class="keyword">public</span> shape&lt;square&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> sidelength;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main中插入</span></span><br><span class="line">square objsq1;</span><br><span class="line">objsq<span class="number">1.</span>sidelength = <span class="number">15</span>;</span><br><span class="line">square objsq2;</span><br><span class="line">objsq<span class="number">2.</span>sidelength = <span class="number">21</span>;</span><br><span class="line"><span class="keyword">if</span>(!(objsq1 ==  objsq2))</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;objsq1和objsq2不相等&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;objsq1和objsq2相等&quot;</span> &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure></li>
<li>基类调用派生类的接口与多态的体现<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Human</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">T&amp; <span class="title">toChild</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T&amp;&gt;(*<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">parenteat</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="built_in">toChild</span>().<span class="built_in">eat</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Men</span> : <span class="keyword">public</span> Human&lt;Men&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;Men eat&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Women</span> : <span class="keyword">public</span> Human&lt;Women&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;Women eat&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myHumanFuncTest</span><span class="params">(Human&lt;T&gt;&amp; tmpobj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  tmpobj.<span class="built_in">parenteat</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main中插入</span></span><br><span class="line">Men mymen;</span><br><span class="line">Women mywomen;</span><br><span class="line"><span class="built_in">myHumanFuncTest</span>(mymen);</span><br><span class="line"><span class="built_in">myHumanFunTest</span>(mywomen);</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Men eat</span><br><span class="line">Women eat</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="混入"><a href="#混入" class="headerlink" title="混入"></a>混入</h3><ul>
<li>常规范例<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">role</span>: <span class="keyword">public</span> T...</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">role</span>(): <span class="built_in">T</span>()..., <span class="built_in">m_attack</span>(<span class="number">0.0</span>), <span class="built_in">m_defence</span>(<span class="number">0.0</span>), <span class="built_in">m_life</span>(<span class="number">100.0</span>)&#123;&#125;</span><br><span class="line">  <span class="built_in">role</span>(<span class="type">double</span> att, <span class="type">double</span> def, <span class="type">double</span> life): <span class="built_in">T</span>()..., <span class="built_in">m_attack</span>(att), <span class="built_in">m_defence</span>(def), <span class="built_in">m_life</span>(life)&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">double</span> m_accack;</span><br><span class="line">  <span class="type">double</span> m_defence;</span><br><span class="line">  <span class="type">double</span> m_life;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_npcattr</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> m_sort;</span><br><span class="line">  std::string m_lang;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> role_npc = role&lt;npcattr&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main中插入</span></span><br><span class="line">role_npc mynpc;</span><br><span class="line">mynpc.m_attack = <span class="number">15</span>;</span><br><span class="line">mynpc.m_defence = <span class="number">10</span>;</span><br><span class="line">mynpc.m_life = <span class="number">120</span>;</span><br><span class="line">mynpc.m_sort = <span class="number">1</span>;</span><br><span class="line">mynpc.mlang = <span class="string">&quot;Are you OK?&quot;</span>;</span><br></pre></td></tr></table></figure>
如果游戏中出现新型NPC 同时拒赔rool_npc和其他属性便可以通过混入的方式组合出来<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_other_property</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125; other_property;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> other_role_npc = role&lt;npcattr, other_property&gt;;</span><br></pre></td></tr></table></figure></li>
<li>用参数化的方式表达成员函数的虚拟性<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> : <span class="keyword">public</span> T...</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">myfunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    std::cout &gt;&gt; <span class="string">&quot;Base::myfunc()执行了！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base&lt;T...&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">myfunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Derived::myfunc()执行了！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 对于以上代码用普通父类指针去创建子类对象，执行myfunc时会执行父类的方法，析构也会有很大的问题</span></span><br><span class="line"><span class="comment">// 如果一个函数在父类中时虚函数，那么子类不用virtual去修饰，该函数一定时虚函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AVir</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">myfunc</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Avir</span>()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main 中插入</span></span><br><span class="line">Base&lt;AVir&gt; *pb = <span class="keyword">new</span> Derived&lt;AVir&gt;; <span class="comment">//  因为AVir中 myfunc是虚函数，所以Base类中的 myfunc也时虚函数，子类也是虚函数</span></span><br><span class="line">pb-&gt;<span class="built_in">myfunc</span>(); </span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="模板代码的足足结构与模板的显示实例化和声明"><a href="#模板代码的足足结构与模板的显示实例化和声明" class="headerlink" title="模板代码的足足结构与模板的显示实例化和声明"></a>模板代码的足足结构与模板的显示实例化和声明</h2><h3 id="模板代码的组织结构"><a href="#模板代码的组织结构" class="headerlink" title="模板代码的组织结构"></a>模板代码的组织结构</h3><h3 id="模板的显式实例化、模板声明、代码组织结构"><a href="#模板的显式实例化、模板声明、代码组织结构" class="headerlink" title="模板的显式实例化、模板声明、代码组织结构"></a>模板的显式实例化、模板声明、代码组织结构</h3>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++泛型</tag>
      </tags>
  </entry>
</search>
