<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++模板与泛型_基础_01</title>
    <url>/Lei_Blog/2024/11/02/C-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B-%E5%9F%BA%E7%A1%80-01/</url>
    <content><![CDATA[<h1 id="模板与基础知识"><a href="#模板与基础知识" class="headerlink" title="模板与基础知识"></a>模板与基础知识</h1><h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><ul>
<li>基础范例  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">Sub</span><span class="params">(T tv1, T tv2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tv1 - tv2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  在main中添加如下代码  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> subv = <span class="built_in">Sub</span>(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">std::cout &lt;&lt; subv &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
  上述是一个函数模板的典型范例，T为模板参数，准确说是类型模板参数，因为其代表一个类型。    </li>
<li>实例化<br>  用具体的类型代替类型模板参数的过程叫做实例化，也称之为代码生成器。</li>
</ul>
<h2 id="模板参数推断"><a href="#模板参数推断" class="headerlink" title="模板参数推断"></a>模板参数推断</h2><ul>
<li>常规的参数推断  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U, <span class="keyword">typename</span> V&gt;</span></span><br><span class="line"><span class="function">V <span class="title">Add</span><span class="params">(T tv1, U tv2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tv1 + tv2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  这个函数模板中定义了3个类型模板参数T、U，V。当如此实例化并调用<code>std::cout &lt;&lt; Add(15, 17) &lt;&lt; std::endl;</code>，一定会发生错误。<br>  因为编译器无法推断出返回值类型V，因此只能手动指定类型，如：<code>std::cout &lt;&lt; Add&lt;..., ..., double&gt;(15, 17) &lt;&lt; std::endl;</code>,<br>  虽然可以指定一定量的模板参数，但编译器是按顺序来知道指定的类型的，只能按顺序去指定模板参数。例如<code>Add&lt;double&gt;(...,...)</code>就会发生错误，<br>  如改成以下方式就可以成功编译,让编译器去推断T，U：  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> V, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">V <span class="title">Add</span><span class="params">(T tv1, U tv2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tv1 + tv2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>关键字推断auto, decltype<br>  auto 结合decltype构成返回类型后置语法，代码如下：  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Add</span><span class="params">(T tv1, U tv2)</span> -&gt; <span class="title">decltype</span><span class="params">(tv1 + tv2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tv1 + tv2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>自动推断，指定推断，指定空模板参数列表     <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">myDouble</span> <span class="params">(T temp_value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> temp_value * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  自动推断<code>int result = myDouble(12)</code>, 此时推断出T为int类型<br>  指定推断<code>int result = myDouble&lt;int&gt;(12)</code>,指定类型为int类型<br>  指定空模板参数<code>auto result = myDouble&lt;&gt;(12.6)</code>,此时编译器根据函数参数推断出T为double类型，<br>  当前情况与<code>auto result = myDouble(12.6)</code>没什么不同，若存在一个普通的myDouble函数，&lt;&gt;就会<br>  发生作用:      <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">myDouble</span> <span class="params">(<span class="type">double</span> temp_value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> temp_value * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  若进行这般调用<code>auto result = myDouble(12.6)</code>，其会调用普通函数。</li>
</ul>
<h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><p>函数（函数模板）重载的概念：函数名相同，但函数参数或类型不同。编译器会更具具体情况选择编译器认为最合适的函数<br>模板实例化或者普通函数进行调用</p>
<ul>
<li>范例  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myfunc</span><span class="params">(T tmpvalue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;myfunc(T)执行了&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  在main中插入如下代码  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">myfunc</span>(<span class="number">12</span>);</span><br><span class="line"><span class="type">char</span>* p = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="built_in">myfunc</span>(p);</span><br></pre></td></tr></table></figure>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">myfunc(T)执行了</span><br><span class="line">myfunc(T)执行了</span><br></pre></td></tr></table></figure>
  以上编译器可以根据不同的参数实例化不同的模板,现添加如下代码  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myfunc</span><span class="params">(T* tmpvalue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;myfunc(T*)执行了&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  重复上过程，和推断的没有差别  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">myfunc(T)执行了</span><br><span class="line">myfunc(T*)执行了</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="特化"><a href="#特化" class="headerlink" title="特化"></a>特化</h2><p>泛化的意思是“大众化”,特化指的是”大众化“中的指定特征“集合”</p>
<ul>
<li>全特化：模板中所有的参数都指定为特定类型<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tfunc</span><span class="params">(T&amp; tmprv, U&amp; tmprv2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::cout &lt;&lt; “泛化版本执行了” &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">tfunc</span>&lt;<span class="type">int</span>, <span class="type">double</span>&gt;(<span class="type">int</span>&amp; tmprv, <span class="type">double</span>&amp; tmprv2)</span><br><span class="line">&#123;</span><br><span class="line">  std::cout &lt;&lt; “全特化版本执行了” &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> k = <span class="number">12</span>;</span><br><span class="line"><span class="type">double</span> db = <span class="number">15.8</span>;</span><br><span class="line"><span class="built_in">tfunc</span>(k, db);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">全特化版本执行了</span><br></pre></td></tr></table></figure></li>
<li>偏特化(局部特化)<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tfunc</span><span class="params">(T&amp; tmprv, U&amp; tmprv2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::cout &lt;&lt; “泛化版本执行了” &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">模板数量上的偏特化 实际上这条编译会出错，数量上来讲函数模板不能篇特化</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">template&lt;typename U&gt;</span></span><br><span class="line"><span class="comment">void tfunc&lt;int, U&gt;(int&amp; tmprv, U&amp; tmprv2)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  std::cout &lt;&lt; “数量上偏特化版本执行了” &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板范围上的偏特化 实际上是函数模板的重载</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tfunc</span><span class="params">(<span class="type">const</span> T&amp; tmprv, U&amp; tmprv2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::cout &lt;&lt; “模板范围上的偏特化执行了” &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">tfunc</span>(a, b);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">模板范围上的偏特化执行了</span><br></pre></td></tr></table></figure></li>
<li>通过重载实现函数模板的偏特化<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tfunc</span><span class="params">(<span class="type">double</span>&amp; tmprv, U&amp; tmprv2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::cout &lt;&lt; “模板参数数量上的偏特化执行了（重载版本）” &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* p = <span class="string">&quot;aaaaa&quot;</span>;</span><br><span class="line"><span class="type">int</span> i = <span class="number">12</span>;</span><br><span class="line"><span class="built_in">tfunc</span>(p, i);</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> j = <span class="number">19.5</span>;</span><br><span class="line"><span class="built_in">tfunc</span>(j, i);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">泛化版本执行了</span><br><span class="line">模板参数数量上的偏特化执行了（重载版本）</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="非类型模板参数"><a href="#非类型模板参数" class="headerlink" title="非类型模板参数"></a>非类型模板参数</h2><p>模板参数不但可以是一个类型，也可以是一个普通的参数，参数还可以是一个默认值</p>
<ul>
<li>范例<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U, <span class="type">int</span> val </span>= <span class="number">0</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Add</span><span class="params">(T tv1, U tv2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> tv1 + tv2 + val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="built_in">Add</span>&lt;<span class="type">float</span>, <span class="type">float</span>&gt;(<span class="number">1.1f</span>, <span class="number">12.3f</span>) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">Add</span>&lt;<span class="type">float</span>, <span class="type">float</span>, <span class="number">1</span>&gt;(<span class="number">1.1f</span>, <span class="number">12.3f</span>) &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">13.4</span><br><span class="line">14.4</span><br></pre></td></tr></table></figure>
以上要注意的点<ul>
<li>在指定非类型模板参数时，一般给的是常量，否则编译报错。</li>
<li>并不是任何类型的参数都可以，int可以，但float, double类型不行，类类型也不可以，不过double* 等指针类型可以</li>
<li>主要有整型或枚举型，指针类型, 左值引用类型,auto或decltype(auto)这个用法…..</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++泛型</tag>
      </tags>
  </entry>
  <entry>
    <title>C++模板与泛型_基础_02</title>
    <url>/Lei_Blog/2024/11/05/C-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B-%E5%9F%BA%E7%A1%80-02/</url>
    <content><![CDATA[<h2 id="类模板、变量模板与别名模板"><a href="#类模板、变量模板与别名模板" class="headerlink" title="类模板、变量模板与别名模板"></a>类模板、变量模板与别名模板</h2><h3 id="类模板的基本范例和模板参数的推断"><a href="#类模板的基本范例和模板参数的推断" class="headerlink" title="类模板的基本范例和模板参数的推断"></a>类模板的基本范例和模板参数的推断</h3><p>类模板，产生类的模具，通过给定的模板参数，生成具体的类</p>
<ul>
<li>基本范例<br>类模板的声明和实现一般都放在同一个头文件中,以下是自定义一个vector<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myvector</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> T* myiterator;</span><br><span class="line">  <span class="comment">//构造函数</span></span><br><span class="line">  <span class="built_in">myvector</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  赋值运算符重载</span></span><br><span class="line"><span class="comment">  在类模板内不使用模板民myvector并不需要提供模板参数，当然也可以提供，可以写成</span></span><br><span class="line"><span class="comment">  myvector&lt;T&gt; </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function">myvector&amp; <span class="title">operator</span><span class="params">(<span class="type">const</span> myvector &amp;)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">myfunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;myfunc 被调用&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">myiterator <span class="title">mybegin</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">myiterator <span class="title">myend</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类外构造</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">myvector&lt;T&gt;::<span class="built_in">myvector</span>()&#123;&#125;</span><br></pre></td></tr></table></figure>
在main函数中插入<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">myvector&lt;<span class="type">int</span>&gt; tmpvec; <span class="comment">// 模板内的T被替换为int</span></span><br><span class="line">tmpvec.<span class="built_in">myfunc</span>();  <span class="comment">// 调用类模板中的普通成员函数</span></span><br></pre></td></tr></table></figure>
运行结果<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">myfunc 被调用</span><br></pre></td></tr></table></figure>
在以上代码中并没有写赋值运算符代码，因为在类模板中只有被调用这些函数编译器才实例化相关代码<br>如果模板中有静态成员函数那么当这个静态成员函数被调用的时候才会实例化，在上代码插入函数，如下<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">mystaticfunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;mystaticfunc() 被调用了&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在main函数中插入<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">myvector&lt;std::string&gt;::<span class="built_in">mystaticfunc</span>();</span><br></pre></td></tr></table></figure>
运行结果<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mystaticfunc() 被调用了</span><br></pre></td></tr></table></figure></li>
<li>模板参数的推断   <ul>
<li>隐式推断<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">A</span>(T val1, T val2)</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;A::A(T val1, T val2)执行了&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
main中插入<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编译器根据参数，推断出类A&lt;int&gt;，进行推断后的代码：A&lt;int&gt; aobj1(15, 16) </span></span><br><span class="line"><span class="function">A <span class="title">aobj1</span><span class="params">(<span class="number">15</span>, <span class="number">16</span>)</span></span>;</span><br></pre></td></tr></table></figure>
结果<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A::A(T val1, T val2)执行了</span><br></pre></td></tr></table></figure>
推断指南的存在意义是为了让编译器推断出模板参数的类型，如<code>A* aobj3=NULL</code>是非法的，可以写成如下形式<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt;</span></span><br><span class="line"><span class="function"><span class="title">A</span><span class="params">(T, T)</span> -&gt; A&lt;<span class="type">double</span>&gt;</span>;</span><br></pre></td></tr></table></figure>
那么代码<code>A aobj(15, 16);</code>类型推断后就会变成<code>A&lt;double&gt; aobj1(15, 16)</code></li>
<li>自定义的推断<br>  让代码编写者按照自己的方式进行推断类型，不进行隐式推断  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt;</span></span><br><span class="line"><span class="function"><span class="title">A</span><span class="params">(T)</span> -&gt; A&lt;T&gt;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//有上代码</span></span></span><br><span class="line"><span class="function">A <span class="title">aobj2</span><span class="params">(<span class="number">12.8</span>)</span></span>; <span class="comment">//有类型推断后相当于A&lt;double&gt; aboj2(12.8)</span></span><br></pre></td></tr></table></figure>
  例子：  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">  T m_b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">B&lt;<span class="type">int</span>&gt; bobj1;</span><br><span class="line">B&lt;<span class="type">int</span>&gt; bobj2&#123;<span class="number">15</span>&#125;;</span><br><span class="line"></span><br><span class="line">B bobj3&#123;<span class="number">15</span>&#125;; <span class="comment">//语法错误 无法推断出bobj3具体类型</span></span><br></pre></td></tr></table></figure>
  针对上错误可以添加一个自定义推断指南  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="title">B</span><span class="params">(T)</span> -&gt; B&lt;T&gt;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="类模板的特化"><a href="#类模板的特化" class="headerlink" title="类模板的特化"></a>类模板的特化</h3><p>开始示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TC</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">TC</span>()</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;TC的泛化版本构造函数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">functest1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;functest1泛化版本&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//mian中添加如下代码</span></span><br><span class="line">TC&lt;<span class="type">int</span>, <span class="type">float</span>&gt; mytc;</span><br><span class="line">mytc.<span class="built_in">functest1</span>();</span><br></pre></td></tr></table></figure>
<p>结果显示</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">TC的泛化版本构造函数</span><br><span class="line">functest1泛化版本</span><br></pre></td></tr></table></figure>
<p>特化的版本是是在泛化的类模板上生成的，先有泛化版本才有特化版本</p>
<ul>
<li>类模板的全特化<br>所谓全特化就是将模板参数全用具体类型指代<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TC</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">TC</span>()</span><br><span class="line">    &#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;TC&lt;int, int&gt;特化版本构造函数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main中添加如下代码</span></span><br><span class="line">TC&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mytc2;</span><br><span class="line">mytc<span class="number">2.f</span>unctest1();</span><br></pre></td></tr></table></figure>
以上会编译报错，因为需要针对特化版本functest1的成员函数进行定义<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TC</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">TC</span>()</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;TC&lt;int, int&gt;特化版本构造函数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">functest1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;functest1特化版本执行了&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">再进行编译，就可以通过了</span><br></pre></td></tr></table></figure>
结果<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TC&lt;int, int&gt;特化版本构造函数</span><br><span class="line">functest1特化版本执行了</span><br></pre></td></tr></table></figure>
对functest1函数在类外编写<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//template&lt;&gt; 这一行不用编写，否则语法报错</span></span><br><span class="line"><span class="type">void</span> TC&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::<span class="built_in">functest1</span>()</span><br><span class="line">&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;functest1泛化版本&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
因为类模板已经全特化，这相当于一个普通类，所以要按照一个普通类的草原函数的实现方法来写</li>
<li>普通成员函数的的全特化    <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">void</span> TC&lt;<span class="type">double</span>, <span class="type">int</span>&gt;::<span class="built_in">functest1</span>()</span><br><span class="line">&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;特化TC&lt;double, int&gt;::functest1() 执行了&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main中添加代码</span></span><br><span class="line">TC&lt;<span class="type">double</span>, <span class="type">int</span>&gt; mytc3;</span><br><span class="line">mytc<span class="number">3.f</span>unctest1();</span><br></pre></td></tr></table></figure>
运行结果<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">TC的泛化版本构造函数</span><br><span class="line">特化TC&lt;double, int&gt;::functest1() 执行了</span><br></pre></td></tr></table></figure></li>
<li>静态成员变量的全特化<br>先在TC类泛化版本中声明静态成员变量<code>static int m_stc;</code><br>然后在类外定义<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="type">int</span> TC&lt;T, U&gt;::m_stc = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在main中添加如下代码</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;mytc3.m_stc = &quot;</span> &lt;&lt; mytc<span class="number">3.</span>m_stc &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
结果<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mytc3.m_stc = 50</span><br></pre></td></tr></table></figure>
对静态成员变量进行全特化<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">int</span> TC&lt;<span class="type">double</span>, <span class="type">int</span>&gt;::m_stc = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在main中添加如下代码</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;mytc3.m_stc = &quot;</span> &lt;&lt; mytc<span class="number">3.</span>m_stc &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
结果<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mytc3.m_stc = 100</span><br></pre></td></tr></table></figure></li>
<li>类模板的偏特化（局部特化）<br>模板参数数量上的偏特化，模板参数范围上的偏特化<ol>
<li>模板参数数量上的偏特化    <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TC</span>&lt;<span class="type">float</span>, U&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">TC</span>()</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;TC&lt;float, U&gt; 偏特化构造函数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">functest1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="type">void</span> TC&lt;<span class="type">float</span>, U&gt;::<span class="built_in">functest1</span>()</span><br><span class="line">&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;TC&lt;float, U&gt;::functest1() 偏特化版本执行了&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main中添加如下代码</span></span><br><span class="line">TC&lt;<span class="type">float</span>, <span class="type">int</span>&gt; mytc4;</span><br><span class="line">mytc<span class="number">4.f</span>unctest1();</span><br></pre></td></tr></table></figure>
 结果 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">TC&lt;float, U&gt; 偏特化构造函数</span><br><span class="line">TC&lt;float, U&gt;::functest1() 偏特化版本执行了</span><br></pre></td></tr></table></figure></li>
<li>模板参数范围上的偏特化    <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TC</span>&lt;<span class="type">const</span> T, U*&gt;</span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">TC</span>()</span><br><span class="line"> &#123;</span><br><span class="line">   std::cout &lt;&lt; <span class="string">&quot;TC&lt;const T, U*&gt; 偏特化版本构造函数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">functest1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="type">void</span> TC&lt;<span class="type">const</span> T, U*&gt;::<span class="built_in">functest1</span>()</span><br><span class="line">&#123;</span><br><span class="line"> std::cout &lt;&lt; <span class="string">&quot;TC&lt;const T, U*&gt;::functest1() 执行了&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在main中添加如下代码</span></span><br><span class="line">TC&lt;<span class="type">const</span> <span class="type">float</span>, <span class="type">int</span> *&gt; mytc5;</span><br><span class="line">mytc<span class="number">5.f</span>unctest1();</span><br></pre></td></tr></table></figure>
结果<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">TC&lt;const T, U*&gt; 偏特化版本构造函数</span><br><span class="line">TC&lt;const T, U*&gt;::functest1() 执行了</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><ul>
<li>常规默认参数<br>类型模板默认参数有一个规矩：如果某个模板参数有默认值，那么从这个有默认值的模板参数开始，后面所有的模板参数都得要有默认值<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T=<span class="type">char</span>, <span class="keyword">typename</span> U=<span class="type">int</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> TC</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mian中可添加如下代码</span></span><br><span class="line">TC&lt;&gt; mytc5;</span><br><span class="line">TC&lt;<span class="type">double</span>&gt; mytc6; </span><br></pre></td></tr></table></figure>
偏特化版本中可以不用有默认值，以下代码编译会报错<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T=<span class="type">char</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> TC&lt;T, <span class="type">int</span>&gt;&#123;&#125;;</span><br></pre></td></tr></table></figure></li>
<li>后面模板参数依赖前模板参数<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U=T*&gt;</span><br><span class="line"><span class="keyword">struct</span> TC&#123;&#125;;</span><br></pre></td></tr></table></figure></li>
<li>在模板中声明指定默认参数<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U, <span class="keyword">typename</span> V=<span class="type">int</span>, <span class="keyword">typename</span> W=<span class="type">char</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> TC;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><ul>
<li>typedef写法<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> TC&lt;<span class="type">int</span>, <span class="type">float</span>&gt; IF_TC;</span><br><span class="line">IF_TC mytc10;</span><br></pre></td></tr></table></figure></li>
<li>using写法<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> IF_TCU = TC&lt;<span class="type">int</span>, <span class="type">float</span>&gt;;</span><br><span class="line">IF_TCU mytc11;</span><br></pre></td></tr></table></figure>
推荐使用using模式</li>
</ul>
<h3 id="非类型模板参数"><a href="#非类型模板参数" class="headerlink" title="非类型模板参数"></a>非类型模板参数</h3><p>模板参数不但可以是一个类型，也可以是一个普通的参数，当然参数也可以给一个默认值   </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U, <span class="type">size_t</span> arr_size=<span class="number">8</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> TC</span><br><span class="line">&#123;</span><br><span class="line">  T m_arr[arr_size];</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">functest2</span><span class="params">()</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// functest2定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U, <span class="type">size_t</span> arr_size&gt;</span><br><span class="line"><span class="type">void</span> TC&lt;T, U, arr_size&gt;::<span class="built_in">functest2</span>()</span><br><span class="line">&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;functest2 泛化版本&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在main中插入如下代码</span></span><br><span class="line">TC&lt;<span class="type">double</span>, <span class="type">double</span>&gt; mytc30;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">size_t</span> i=<span class="number">0</span>; i&lt;<span class="number">8</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">  mytc<span class="number">30.</span>m_arr[i] = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样，如果将size_t替换为auto也是可以的，不过非类型模板参数有一些限制（常量，类型一般限制在整型、指针类型）</p>
<ol>
<li>全局指针不能作为模板参数     <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">const</span> <span class="type">char</span> *p&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TC2</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">TC2</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* g_s = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main中插入如下代码 </span></span><br><span class="line">TC2&lt;g_s&gt; mytc40; <span class="comment">//编译报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 把g_s修改以下定义就可以正常编译</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> g_s[] = <span class="string">&quot;hello&quot;</span>;</span><br></pre></td></tr></table></figure></li>
<li>字符串常量也无法作为模板参数     <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">TC2&lt;<span class="string">&quot;hello&quot;</span>&gt; mytc41;</span><br><span class="line"><span class="comment">//编译报错提示 模板参数的表达式无效</span></span><br></pre></td></tr></table></figure></li>
<li>float、double这样的浮点数不允许作为非类型模板参数，应为这两个数都是不精确的</li>
</ol>
<h3 id="成员函数模板"><a href="#成员函数模板" class="headerlink" title="成员函数模板"></a>成员函数模板</h3><ul>
<li>基本含义、构造函数模板<br>不管普通类还是类模板，都可以为其定义成员模板函数<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function">  <span class="title">A</span><span class="params">(T2 v1, T2 v2)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T3&gt;</span></span><br><span class="line"><span class="function">  <span class="type">void</span> <span class="title">myft</span><span class="params">(T3 tmpt)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; tmpt &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">  T1 m_ic;</span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> m_stcvalue = <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类外实现模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1&gt;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T2&gt;</span><br><span class="line">A&lt;T1&gt;::<span class="built_in">A</span>(T2 v1, T2 v2)</span><br><span class="line">&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;A::A(T2, T2)执行了&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>拷贝构造函数模板与拷贝赋值运算符模板<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 拷贝构造模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function"><span class="title">A</span><span class="params">(<span class="type">const</span> A&lt;U&gt;&amp; other)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;A::A(const A&lt;U&gt;&amp; other) 拷贝构造函数模板执行了&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拷贝赋值运算符模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">A&lt;T1&gt;&amp; <span class="keyword">operator</span> = (<span class="type">const</span> A&lt;U&gt;&amp; other)</span><br><span class="line">&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;operator=(const A&lt;U&gt;&amp; other) 拷贝赋值运算符执行了&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
注意点:<ul>
<li>拷贝构造函数模板不是拷贝构造函数，拷贝赋值运算符模板不是拷贝赋值运算符。因为拷贝构造函数或拷贝赋值运算符要求拷贝的对象类型完全相同，而拷贝构造函数&#x2F;运算符的模板没这种要求</li>
</ul>
</li>
<li>特化<br>类模板定义中插入如下代码<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T3, <span class="keyword">typename</span> T4&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myft</span><span class="params">(T3 tmp1, T4 tmp2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;myft() 泛化版本&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T4&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myft</span><span class="params">(<span class="type">int</span> tmp1, T4 tmp2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;myft() 偏特化版本&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myft</span><span class="params">(<span class="type">int</span> tmp1, <span class="type">int</span> tmp2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;myft() 全特化版本&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
类外编写<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1&gt;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T4&gt;</span><br><span class="line"><span class="type">void</span> A&lt;T1&gt;::<span class="built_in">myft</span>(<span class="type">int</span> tmp1, T4 tmp2)</span><br><span class="line">&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;myft() 偏特化版本&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//全特化版本编译会出错 c++标准不允许类模板之外全特化一个未被特化的类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1&gt;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">void</span> A&lt;T1&gt;::<span class="built_in">myft</span>(<span class="type">int</span> tmp1, <span class="type">int</span> tmp2)</span><br><span class="line">&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;myft() 全特化版本&quot;</span>&lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对于以上全特化类外编写可以全特化一个类模板A</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&lt;<span class="type">float</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T3, <span class="keyword">typename</span> T4&gt;</span></span><br><span class="line"><span class="function">  <span class="type">void</span> <span class="title">myft</span><span class="params">(T3 tmp1, T4 tmp2)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;myft() 泛化版本&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// A&lt;float&gt;中有泛化版本的myft()，因此不用在A&lt;float&gt;中生命如下的全特化版本</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">void</span> A&lt;<span class="type">float</span>&gt;::<span class="built_in">myft</span>(<span class="type">int</span> tmp1, <span class="type">float</span> tmp2)</span><br><span class="line">&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;myft() 全特化版本&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
现实编码中建议将特化版卸载模板类的内部，类模板一般都要写在头文件中</li>
</ul>
<h3 id="类-类模板中的类模板-类模板的嵌套"><a href="#类-类模板中的类模板-类模板的嵌套" class="headerlink" title="类&#x2F;类模板中的类模板(类模板的嵌套)"></a>类&#x2F;类模板中的类模板(类模板的嵌套)</h3><p>在类模板A<float>全特化插入如下代码，示例：      </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">OtherC</span></span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">myfOC</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;myfOC 执行了&quot;</span> &lt;&lt; std::endl; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="comment">/************************************************/</span></span><br><span class="line"><span class="comment">//类外定义myfOC()</span></span><br><span class="line"><span class="comment">// template&lt;&gt; 这一行可以不用添加 A&lt;float&gt;当成一个正常的类来看待</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="type">void</span> A&lt;<span class="type">float</span>&gt;::OtherC&lt;U&gt;::<span class="built_in">myfOC</span>()</span><br><span class="line">&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;myfOC 执行了&quot;</span> &lt;&lt; std::endl; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************/</span></span><br><span class="line"><span class="comment">// 在main中插入如下代码</span></span><br><span class="line">A&lt;<span class="type">float</span>&gt;::OtherC&lt;<span class="type">float</span>&gt; myobjc;</span><br><span class="line">myobjc.<span class="built_in">myfOC</span>();</span><br></pre></td></tr></table></figure>
<p>执行结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">myfOC 执行了</span><br></pre></td></tr></table></figure>
<p>如果myfOC插入了泛化版本,类外实现版本如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1&gt;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="type">void</span> A&lt;T1&gt;::Other&lt;U&gt;::<span class="built_in">myfOC</span>()</span><br><span class="line">&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;myfOC 执行了&quot;</span> &lt;&lt; std::endl; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="变量模板与成员变量模板"><a href="#变量模板与成员变量模板" class="headerlink" title="变量模板与成员变量模板"></a>变量模板与成员变量模板</h3><p>变量模板Variable Templates,C++14标准引入。一般定义在全局空间或命名空间中（.h文件内）<br>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T g_myvar&#123;&#125;; <span class="comment">// &#123;&#125;代表零初始化 bool:false number:0  point:nullptr。如不进行零初始化，局部变量随机</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>变量模板的特化<ol>
<li>变量模板的全特化 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T g_myvar&#123;&#125;;</span><br><span class="line"><span class="comment">// 针对变量模板g_myvar特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">char</span> g_myvar&lt;<span class="type">double</span>&gt;&#123;&#125;;  <span class="comment">//针对此类模板特化时，并不需要考虑特化类型double与这个变量模板类型char一致</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// main中插入如下代码</span></span><br><span class="line">g_myvar&lt;<span class="type">double</span>&gt; = <span class="string">&#x27;2&#x27;</span>; <span class="comment">// 其存储的变量是char类型，值为‘2’</span></span><br></pre></td></tr></table></figure></li>
<li>变量模板的偏特化 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T g_myvar&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//特化版本</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T g_myvar&lt;T *&gt;&#123;<span class="number">120</span>&#125;; <span class="comment">//T 表示模板类型， T * 表示正在特化的类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// main中插入如下代码</span></span><br><span class="line">std::cout &lt;&lt; g_myvar&lt;<span class="type">int</span> *&gt; &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; g_myvar&lt;<span class="type">int</span>&gt; &lt;&lt; std::endl; </span><br></pre></td></tr></table></figure>
 结果 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">120</span><br><span class="line">0</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>默认模板参数<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T=<span class="type">int</span>&gt;</span><br><span class="line">T g_myvar;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main中插入如下代码</span></span><br><span class="line">g_myvar&lt;<span class="type">int</span>&gt; = <span class="number">13</span>;</span><br><span class="line">g_myvar&lt;&gt; = <span class="number">26</span>; <span class="comment">// g_myvar&lt;int&gt; 等价于g_myvar，最后g_myvar&lt;int&gt;的值为26;</span></span><br></pre></td></tr></table></figure></li>
<li>非类型模板参数<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">int</span> value&gt;</span><br><span class="line">T g_myvar3[value];</span><br><span class="line"></span><br><span class="line"><span class="comment">// main中插入如下代码</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">15</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">  g_myvar&lt;<span class="type">int</span>, <span class="number">15</span>&gt;[i] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>变量模板的另一种形式<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">static</span> T value = &#123;<span class="number">160</span>&#125;; <span class="comment">//const 也可以写成constexpr,&#123;&#125;可以不加</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> g_myvar4 = B&lt;T&gt;::value; <span class="comment">// 注意g_myvar4是个变量模板</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// main中插入如下代码</span></span><br><span class="line">std::cout &lt;&lt; g_myvar4&lt;<span class="type">int</span>&gt; &lt;&lt; std::endl; <span class="comment">//160</span></span><br><span class="line">g_myvar4&lt;<span class="type">int</span>&gt; = <span class="number">152</span>;</span><br><span class="line">std::cout &lt;&lt; g_myvar4&lt;<span class="type">int</span>&gt; &lt;&lt; std::endl; <span class="comment">//152</span></span><br><span class="line">std::cout &lt;&lt; B&lt;<span class="type">int</span>&gt;::value &lt;&lt; std::endl; <span class="comment">// 160 value值不发生变化</span></span><br></pre></td></tr></table></figure></li>
<li>成员变量模板<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> W&gt;</span><br><span class="line">  <span class="type">static</span> W m_tpi; <span class="comment">//静态成员变量模板声明</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类外定义静态成员变量</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> W&gt;</span><br><span class="line">W D&lt;T&gt;::m_tpi = <span class="number">5</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="别名模板与成员别名模板"><a href="#别名模板与成员别名模板" class="headerlink" title="别名模板与成员别名模板"></a>别名模板与成员别名模板</h3><p>别名模板Alias Templates C++11标准引入，引入目的是为了简化书写，示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="type">str_map_t</span> = std::map&lt;std::string, T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main 中插入</span></span><br><span class="line"><span class="type">str_map_t</span>&lt;<span class="type">int</span>&gt; map1;</span><br><span class="line">map<span class="number">1.</span><span class="built_in">insert</span>(&#123;<span class="string">&quot;first&quot;</span>, <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>也可以放在类或者类模板中</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">E</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="keyword">using</span> <span class="type">str_map_t</span> = std::map&lt;std::string, T&gt;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">str_map_t</span>&lt;<span class="type">int</span>&gt; map1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main 中插入</span></span><br><span class="line">E&lt;<span class="type">float</span>&gt; obja;</span><br><span class="line">obja.map<span class="number">1.</span><span class="built_in">insert</span>(&#123;<span class="string">&quot;first&quot;</span>, <span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="模板模板参数"><a href="#模板模板参数" class="headerlink" title="模板模板参数"></a>模板模板参数</h3><p>模板模板参数 Template Template Parmeters, 意思是让模板参数本身从未模板，如<code>myclass&lt;int, vector&gt;</code><br>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误示范</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Container = std::vector&gt;</span><br><span class="line"><span class="keyword">class</span> myclass</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Container&lt;T&gt; myc;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为Container 是类型模板参数，不是模板模板参数，所以要告诉编译器Container是模板模板参数</span></span><br><span class="line"><span class="keyword">template</span>&lt;</span><br><span class="line">  <span class="keyword">typename</span> T, </span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">class</span>&gt; <span class="keyword">class</span> <span class="title class_">Container</span> = std::vector</span><br><span class="line">&gt;</span><br><span class="line"><span class="keyword">class</span> myclass</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Container&lt;T&gt; myc;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**************************/</span></span><br><span class="line"><span class="comment">// 也可以有如下写法</span></span><br><span class="line"><span class="keyword">template</span>&lt;</span><br><span class="line">  <span class="keyword">template</span> T,</span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> W&gt; <span class="keyword">typename</span> Container = std::vector</span><br><span class="line">&gt;</span><br><span class="line"><span class="keyword">class</span> myclass</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Container&lt;T&gt; myc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>特别声明：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 上述代码中W看成是Container的类型模板参数，W无论如何也是是用不到的，也不能在类中使用，通常省略。</span></span><br><span class="line"><span class="keyword">template</span>&lt;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">template</span>&lt;typenameW, W* point&gt; <span class="keyword">typename</span> Container</span><br><span class="line">&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myclass2</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//W *m_p 此处报错</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另外如果类模板中不是Container也可以将其省略，于是出现如下写法</span></span><br><span class="line"><span class="keyword">template</span>&lt;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt; <span class="keyword">typename</span> = std::vector</span><br><span class="line">&gt;</span><br><span class="line"><span class="keyword">class</span> myclass3</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="共用体模板-联合模板"><a href="#共用体模板-联合模板" class="headerlink" title="共用体模板(联合模板)"></a>共用体模板(联合模板)</h3><p>与结构体很相似，只不过共用体是把几种不同类型的变量存放到一段内存单元。 Union Templates<br>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">union</span> <span class="title class_">myuni</span></span><br><span class="line">&#123;</span><br><span class="line">  T carnum;</span><br><span class="line">  U cartype;</span><br><span class="line">  U cname[<span class="number">60</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main 中插入</span></span><br><span class="line">myuni&lt;<span class="type">int</span>,<span class="type">char</span>&gt; myu;</span><br><span class="line">myu.carnum = <span class="number">156</span>;</span><br><span class="line">std::cout &lt;&lt; myu.carnum &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">156</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++泛型</tag>
      </tags>
  </entry>
  <entry>
    <title>C++模板与泛型_基础_03</title>
    <url>/Lei_Blog/2024/11/09/C-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B-%E5%9F%BA%E7%A1%80-03/</url>
    <content><![CDATA[<h2 id="类模板中的友元"><a href="#类模板中的友元" class="headerlink" title="类模板中的友元"></a>类模板中的友元</h2><h3 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h3><p>让某个类B成为另外一个类A的友，这样B类就可以访问类A的所有变量和函数</p>
<ul>
<li><p>让类模板某个实例成为友元</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">callBAF</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      A&lt;<span class="type">int</span>&gt; atmpobj;</span><br><span class="line">      atmpobj.data = <span class="number">5</span>;</span><br><span class="line">      std::cout &lt;&lt; atmpobj.data &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// main 中插入</span></span><br><span class="line">B&lt;<span class="type">long</span>&gt; bobj;</span><br><span class="line">bobj.<span class="built_in">callFAF</span>();</span><br></pre></td></tr></table></figure>
<p>但上述代码会报错，因为模板类B<long>，不是A<int>的友元类，在类B中无法访问A<int>中的私有变量,修改如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">B</span>&lt;<span class="type">long</span>&gt;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>做如上修改就可以让B<long>,访问模板类A中的元素了</p>
</li>
<li><p>让类模板成为友元类模板<br>上面仅限于B<long>是模板类A的友元，如何让模板类B也成为A的友元，不限定模板参数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt; <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>做出如上修改就可以实现了</p>
</li>
<li><p>让类模板参数成为友元      </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">friend</span> T;</span><br><span class="line">  <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AF</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">callAFAF</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      A&lt;AF&gt; aobj;</span><br><span class="line">      aobj.data = <span class="number">12</span>;</span><br><span class="line">      std::cout &lt;&lt; aobj.data &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h3><p>函数模板可以被声明为友元函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U, <span class="keyword">typename</span> V&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(U val1, V val2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Men</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U, <span class="keyword">typename</span> V&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">friend</span> <span class="type">void</span> <span class="title">func</span><span class="params">(U val1, V val2)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">funcman</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Men::funcman 被调用了&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U, <span class="keyword">typename</span> V&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(U val1, V val2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Men mymen;</span><br><span class="line">    mymen.<span class="built_in">funcman</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>让函数模板的某个实例成为友元函数<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Men</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">void</span> <span class="built_in">func</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="type">int</span> val1, <span class="type">int</span> val2);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">funcman</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Men::funcman 被调用了&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>在类模板中定义友元函数<br>这种写法会比较奇怪，友元函数可以在类外调用，虽然写在类模板中，但应看作全局函数<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Z&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Men</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">func</span><span class="params">(Men&lt;Z&gt; &amp;tmpmen)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      tmpmen.<span class="built_in">funcmen</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main中插入代码</span></span><br><span class="line">Men&lt;<span class="type">double</span>&gt; mynen1;</span><br><span class="line"><span class="built_in">func</span>(mynen2);</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++泛型</tag>
      </tags>
  </entry>
  <entry>
    <title>C++模板与泛型_基础_05</title>
    <url>/Lei_Blog/2024/11/13/C-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B-%E5%9F%BA%E7%A1%80-05/</url>
    <content><![CDATA[<h2 id="多态在模板中应用"><a href="#多态在模板中应用" class="headerlink" title="多态在模板中应用"></a>多态在模板中应用</h2><p>一个简单的例子</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Men</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Men eat&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Women</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Women eat&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eatPerson</span><span class="params">(T&amp; person)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    person.<span class="built_in">eat</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>传统的多台叫做动态多态（运行时多态），要访问虚函数表指针，在层序执行性能上会有一些影响，而在模板中运用在编译时期就确定了调用谁，因此不存在性能问题，这种多态较静态多态</p>
<h2 id="模板的特殊继承关系"><a href="#模板的特殊继承关系" class="headerlink" title="模板的特殊继承关系"></a>模板的特殊继承关系</h2><h3 id="奇异的递归模板模式"><a href="#奇异的递归模板模式" class="headerlink" title="奇异的递归模板模式"></a>奇异的递归模板模式</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived1</span> : <span class="keyword">public</span> Base&lt;Derived1&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">myfunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived1::myfunc() 执行了&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived2</span> : <span class="keyword">public</span> Base&lt;Derived2&lt;T&gt;&gt;</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>在基类中使用派生类对象<br>在Base基类模板中添加一个public修饰的成员函数asDerived();<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">asDerived</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      T&amp; derived = <span class="built_in">static_cast</span>&lt;T&amp;&gt;(*<span class="keyword">this</span>);</span><br><span class="line">      derived.<span class="built_in">myfunc</span>();  <span class="comment">//调用派生类的成员函数</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// main中插入</span></span><br><span class="line">Derived1 myd;</span><br><span class="line">myd.<span class="built_in">asDerived</span>();</span><br></pre></td></tr></table></figure></li>
<li>基于减少派生类中代码的考虑<br>基于代码量的考虑的出发点是尽可能把一些代码挪到基类中去，从而减少派生类代码量<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">shape</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> == (<span class="type">const</span> shape&lt;T&gt;&amp; obj1, <span class="type">const</span> shape&lt;T&gt;&amp; boj2)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="type">const</span> T&amp; objtmp1 = <span class="built_in">static_cast</span>&lt;<span class="type">const</span> T&amp;&gt;(obj1);</span><br><span class="line">      <span class="type">const</span> T&amp; objtmp2 = <span class="built_in">static_cast</span>&lt;<span class="type">const</span> T&amp;&gt;(obj2);</span><br><span class="line">      <span class="keyword">if</span>(!(objtmp1 &lt; objtmp2) &amp;&amp; !(objtmp2 &lt; objtmp1))</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">squere</span> : <span class="keyword">public</span> shape&lt;square&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> sidelength;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main中插入</span></span><br><span class="line">square objsq1;</span><br><span class="line">objsq<span class="number">1.</span>sidelength = <span class="number">15</span>;</span><br><span class="line">square objsq2;</span><br><span class="line">objsq<span class="number">2.</span>sidelength = <span class="number">21</span>;</span><br><span class="line"><span class="keyword">if</span>(!(objsq1 ==  objsq2))</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;objsq1和objsq2不相等&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;objsq1和objsq2相等&quot;</span> &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure></li>
<li>基类调用派生类的接口与多态的体现<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Human</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">T&amp; <span class="title">toChild</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T&amp;&gt;(*<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">parenteat</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="built_in">toChild</span>().<span class="built_in">eat</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Men</span> : <span class="keyword">public</span> Human&lt;Men&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;Men eat&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Women</span> : <span class="keyword">public</span> Human&lt;Women&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;Women eat&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myHumanFuncTest</span><span class="params">(Human&lt;T&gt;&amp; tmpobj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  tmpobj.<span class="built_in">parenteat</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main中插入</span></span><br><span class="line">Men mymen;</span><br><span class="line">Women mywomen;</span><br><span class="line"><span class="built_in">myHumanFuncTest</span>(mymen);</span><br><span class="line"><span class="built_in">myHumanFunTest</span>(mywomen);</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Men eat</span><br><span class="line">Women eat</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="混入"><a href="#混入" class="headerlink" title="混入"></a>混入</h3><ul>
<li>常规范例<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">role</span>: <span class="keyword">public</span> T...</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">role</span>(): <span class="built_in">T</span>()..., <span class="built_in">m_attack</span>(<span class="number">0.0</span>), <span class="built_in">m_defence</span>(<span class="number">0.0</span>), <span class="built_in">m_life</span>(<span class="number">100.0</span>)&#123;&#125;</span><br><span class="line">  <span class="built_in">role</span>(<span class="type">double</span> att, <span class="type">double</span> def, <span class="type">double</span> life): <span class="built_in">T</span>()..., <span class="built_in">m_attack</span>(att), <span class="built_in">m_defence</span>(def), <span class="built_in">m_life</span>(life)&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">double</span> m_accack;</span><br><span class="line">  <span class="type">double</span> m_defence;</span><br><span class="line">  <span class="type">double</span> m_life;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_npcattr</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> m_sort;</span><br><span class="line">  std::string m_lang;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> role_npc = role&lt;npcattr&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main中插入</span></span><br><span class="line">role_npc mynpc;</span><br><span class="line">mynpc.m_attack = <span class="number">15</span>;</span><br><span class="line">mynpc.m_defence = <span class="number">10</span>;</span><br><span class="line">mynpc.m_life = <span class="number">120</span>;</span><br><span class="line">mynpc.m_sort = <span class="number">1</span>;</span><br><span class="line">mynpc.mlang = <span class="string">&quot;Are you OK?&quot;</span>;</span><br></pre></td></tr></table></figure>
如果游戏中出现新型NPC 同时拒赔rool_npc和其他属性便可以通过混入的方式组合出来<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_other_property</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125; other_property;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> other_role_npc = role&lt;npcattr, other_property&gt;;</span><br></pre></td></tr></table></figure></li>
<li>用参数化的方式表达成员函数的虚拟性<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> : <span class="keyword">public</span> T...</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">myfunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    std::cout &gt;&gt; <span class="string">&quot;Base::myfunc()执行了！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base&lt;T...&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">myfunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Derived::myfunc()执行了！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 对于以上代码用普通父类指针去创建子类对象，执行myfunc时会执行父类的方法，析构也会有很大的问题</span></span><br><span class="line"><span class="comment">// 如果一个函数在父类中时虚函数，那么子类不用virtual去修饰，该函数一定时虚函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AVir</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">myfunc</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Avir</span>()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main 中插入</span></span><br><span class="line">Base&lt;AVir&gt; *pb = <span class="keyword">new</span> Derived&lt;AVir&gt;; <span class="comment">//  因为AVir中 myfunc是虚函数，所以Base类中的 myfunc也时虚函数，子类也是虚函数</span></span><br><span class="line">pb-&gt;<span class="built_in">myfunc</span>(); </span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="模板代码的足足结构与模板的显示实例化和声明"><a href="#模板代码的足足结构与模板的显示实例化和声明" class="headerlink" title="模板代码的足足结构与模板的显示实例化和声明"></a>模板代码的足足结构与模板的显示实例化和声明</h2><h3 id="模板代码的组织结构"><a href="#模板代码的组织结构" class="headerlink" title="模板代码的组织结构"></a>模板代码的组织结构</h3><h3 id="模板的显式实例化、模板声明、代码组织结构"><a href="#模板的显式实例化、模板声明、代码组织结构" class="headerlink" title="模板的显式实例化、模板声明、代码组织结构"></a>模板的显式实例化、模板声明、代码组织结构</h3>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++泛型</tag>
      </tags>
  </entry>
  <entry>
    <title>C++模板与泛型_基础_04</title>
    <url>/Lei_Blog/2024/11/11/C-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B-%E5%9F%BA%E7%A1%80-04/</url>
    <content><![CDATA[<h3 id="可变参数模板"><a href="#可变参数模板" class="headerlink" title="可变参数模板"></a>可变参数模板</h3><h3 id="可变函数模板"><a href="#可变函数模板" class="headerlink" title="可变函数模板"></a>可变函数模板</h3><ul>
<li>基本含义<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... T &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myvtfunc</span><span class="params">(T... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;--------------begin-------------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="keyword">sizeof</span>...(args) &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="keyword">sizeof</span>...(T) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;--------------end---------------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mian 中插入</span></span><br><span class="line"><span class="built_in">myvtfunc</span>();</span><br><span class="line"><span class="built_in">myvtfunc</span>(<span class="number">10</span>, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line"><span class="built_in">myvtfunc</span>&lt;<span class="type">double</span>, <span class="type">int</span>&gt;(<span class="number">10</span>, <span class="number">25</span>, <span class="string">&quot;abc&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">--------------begin-------------------</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">--------------end---------------------</span><br><span class="line">--------------begin-------------------</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">--------------end---------------------</span><br><span class="line">--------------begin-------------------</span><br><span class="line">4</span><br><span class="line">4</span><br><span class="line">--------------end---------------------</span><br></pre></td></tr></table></figure>
<ul>
<li>typename后面带了三个点，然后修饰T</li>
<li>T后面带了…，T称可变参数类型</li>
</ul>
</li>
<li>参数包的展开<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加一个递归终止函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myvtfunct</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;终止函数执行&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... U&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myvtfunct</span><span class="params">(T firstarg, U ...otherargs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;收到的值为：&quot;</span> &lt;&lt; firstarg &lt;&lt; std::endl;</span><br><span class="line">  <span class="built_in">myvtfunct</span>(otherargs...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main中插入</span></span><br><span class="line"><span class="built_in">myvtfunct</span>(<span class="number">10</span>, <span class="string">&quot;abc&quot;</span>, <span class="number">10.5</span>, <span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">收到的值为：10</span><br><span class="line">收到的值为：abc</span><br><span class="line">收到的值为：10.5</span><br><span class="line">收到的值为：a</span><br><span class="line">终止函数执行</span><br></pre></td></tr></table></figure>
c++17标准的另外一种写法<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>...U&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myvtfunc</span><span class="params">(T firstarg, U ...otherargs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;收到的参数值为：&quot;</span> &lt;&lt; firstarg &lt;&lt; std::endl;</span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span><span class="params">(<span class="keyword">sizeof</span>...(otherargs) &gt; <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">myvtfunct</span>(otherargs...);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//什么也不做</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>重载<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myfunc</span><span class="params">(T... arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;myfunc(T.. arg)执行了&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myfunc</span><span class="params">(T*... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;myfunc(T*... args)执行了&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myfunc</span><span class="params">(<span class="type">int</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;myfunc(int arg)执行了&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main中插入</span></span><br><span class="line"><span class="built_in">myfunc</span>(<span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">myfunc</span>(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">myfunc</span>((<span class="type">int</span>*)<span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">myfunc(T.. arg)执行了</span><br><span class="line">myfunc(T.. arg)执行了</span><br><span class="line">myfunc(T*... args)执行了</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="折叠表达式"><a href="#折叠表达式" class="headerlink" title="折叠表达式"></a>折叠表达式</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add_val</span><span class="params">(T... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (... + args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main中插入</span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">add_val</span>(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>) &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">60</span><br></pre></td></tr></table></figure>
<ul>
<li>一元左折与一元右折<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一元左折（（（参数1 运算符 参数2）运算符 参数3）...运算符 参数N）</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sub_val_left</span><span class="params">(T... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (... - args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 亿元右折 （参数1 运算符（...（参数N-1 运算符 参数N）））</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sub_val_right</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (args - ...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main中插入</span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">sub_val_left</span>(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>) &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">/// 10-20-30-40</span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">sub_val_right</span>(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>) &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">// 10-(20-(30-40))</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-80</span><br><span class="line">-20</span><br></pre></td></tr></table></figure></li>
<li>二元左折与二元右折<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sub_value_left_b</span><span class="params">(T ... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="number">220</span> - ... - args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sub_value_right_b</span><span class="params">(T ... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (args - ... <span class="number">-220</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main中插入</span></span><br><span class="line"><span class="comment">// ((220 - 10) - 20) - 30</span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">sub_value_left_b</span>(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>) &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">// (10 - (20 - (30 - 220)))</span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">sub_value_right_b</span>(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>) &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="可变参表达式"><a href="#可变参表达式" class="headerlink" title="可变参表达式"></a>可变参表达式</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">print_result</span><span class="params">(T <span class="type">const</span>&amp; ... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  (std::cout &lt;&lt; ... &lt;&lt; args) &lt;&lt; <span class="string">&quot; 结束&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> (... + args); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main中插入</span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">print_result</span>(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>) &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">102030 结束</span><br><span class="line">60</span><br></pre></td></tr></table></figure>
<p>带参数版本</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_calc</span><span class="params">(T <span class="type">const</span>&amp; ... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  </span><br><span class="line">  std::cout &lt;&lt; <span class="built_in">print_result</span>(<span class="number">2</span>* args...) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main中插入 内部函数等价于 print_result(20, 40, 60)</span></span><br><span class="line"><span class="built_in">print_calc</span>(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">204060</span><br><span class="line">120</span><br></pre></td></tr></table></figure>
<p>注意：数字与 … 之间要有空格隔开</p>
<h3 id="可变参类模板"><a href="#可变参类模板" class="headerlink" title="可变参类模板"></a>可变参类模板</h3><ul>
<li>通过递归继承方式展开类型、非类型、模板模板参数包<ol>
<li>类型模板参数包的展开 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> First, <span class="keyword">typename</span>... Others&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myclasst</span>&lt;First, Others...&gt; : <span class="keyword">private</span> myclasst&lt;Others&gt; </span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...Args&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myclasst</span></span><br><span class="line">&#123; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
 偏特化 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Others&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myclasst</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> First, <span class="keyword">typename</span>... Others&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myclasst</span>&lt;First, Others...&gt; : <span class="keyword">private</span> myclasst&lt;Others...&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">myclasst</span>():<span class="built_in">m_i</span>(<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;myclasst::myclasst() 偏特化版本执行了this position: &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot; sizeof...(Others): &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>...(Others) &lt;&lt; std::endl; </span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  First m_i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 主模板</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Others&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myclasst</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">myclasst</span>()</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;myclast:;myclasst() 泛化版本执行了，this position: &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// mian中插入</span></span><br><span class="line">myclasst&lt;<span class="type">int</span>, <span class="type">float</span>, <span class="type">double</span>&gt; myc;</span><br></pre></td></tr></table></figure>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">myclast:;myclasst() 泛化版本执行了，this position: 0x7fff587587a0</span><br><span class="line">myclasst::myclasst() 偏特化版本执行了this position: 0x7fff587587a0 sizeof...(Others): 0</span><br><span class="line">myclasst::myclasst() 偏特化版本执行了this position: 0x7fff587587a0 sizeof...(Others): 1</span><br><span class="line">myclasst::myclasst() 偏特化版本执行了this position: 0x7fff587587a0 sizeof...(Others): 2</span><br></pre></td></tr></table></figure>
 需要注意的点<ul>
<li>带3个点的参数不能超过1个</li>
<li>一般带点的参数要放在最后</li>
<li>上两点对对参数特化不适用</li>
</ul>
</li>
<li>非类型模板参数包的展开 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span>... Args&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myclasst</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">myclasst</span>()</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;myclast::myclasst() 泛化版本执行了 this pos: &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> First, <span class="type">int</span>... Others&gt; <span class="comment">/// int 换成auto也可以</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myclasst</span>&lt;First, Others...&gt; : <span class="keyword">private</span> myclasst&lt;Others...&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">myclasst</span>()</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;myclasst::myclast() 偏特化版本执行了 this pos: &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot; sizeof...(Others): &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>...(Others) &lt;&lt; <span class="string">&quot;   First is &quot;</span>&lt;&lt; First &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main中插入</span></span><br><span class="line">myclasst&lt;<span class="number">12</span>, <span class="number">18</span>, <span class="number">23</span>&gt; myt;</span><br></pre></td></tr></table></figure>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">myclast::myclasst() 泛化版本执行了 this pos: 0x7ffc139d54e7</span><br><span class="line">myclasst::myclast() 偏特化版本执行了 this pos: 0x7ffc139d54e7 sizeof...(Others): 0   First is 23</span><br><span class="line">myclasst::myclast() 偏特化版本执行了 this pos: 0x7ffc139d54e7 sizeof...(Others): 1   First is 18</span><br><span class="line">myclasst::myclast() 偏特化版本执行了 this pos: 0x7ffc139d54e7 sizeof...(Others): 2   First is 12</span><br></pre></td></tr></table></figure></li>
<li>模板模板参数包的展开   <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,</span><br><span class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt; <span class="keyword">typename</span>... Container</span><br><span class="line">&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ParentMM</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">ParentMM</span>()</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ParentMM::ParentMM()执行了，this = &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;</span><br><span class="line">  <span class="keyword">typename</span> T,</span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt; <span class="keyword">typename</span> FirstContainer, <span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt; <span class="keyword">typename</span>... OtherContainers</span><br><span class="line">&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ParentMM</span>&lt;T, FirstContainer, OtherContainers...&gt; : <span class="keyword">private</span> ParentMM&lt;T, OtherContainers...&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">ParentMM</span>()</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ParentMM::ParentMM()偏特化执行了，this=&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot;  sizeof...(OtherContainers):&quot;</span> &lt;&lt; <span class="keyword">sizeof</span>...(OtherContainers) &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  FirstContainer&lt;T&gt; m_container;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;</span><br><span class="line">  <span class="keyword">typename</span> T, </span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt; <span class="keyword">typename</span>... Container</span><br><span class="line">&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myclass</span> : <span class="keyword">private</span> ParentMM&lt;T, Container...&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">myclass</span>()</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;mycalss::myclass() 执行了 this = &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot;  sizeof...(Container): &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>...(Container) &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main中插入</span></span><br><span class="line">myclass&lt;<span class="type">int</span>, std::vector, std::list, std::deque&gt; myc;</span><br></pre></td></tr></table></figure>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ParentMM::ParentMM()执行了，this = 0x7ffe4dace040</span><br><span class="line">ParentMM::ParentMM()偏特化执行了，this=0x7ffe4dace040  sizeof...(OtherContainers):0</span><br><span class="line">ParentMM::ParentMM()偏特化执行了，this=0x7ffe4dace040  sizeof...(OtherContainers):1</span><br><span class="line">ParentMM::ParentMM()偏特化执行了，this=0x7ffe4dace040  sizeof...(OtherContainers):2</span><br><span class="line">mycalss::myclass() 执行了 this = 0x7ffe4dace040  sizeof...(Container): 3</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>通过递归组合方式展开参数包<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...args&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myclass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">myclass</span>()</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;myclass::myclass()泛化版本执行了，this=&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> First, <span class="keyword">typename</span>... Others&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myclass</span>&lt;First, Others...&gt;<span class="comment">//: private myclass&lt;Others...&gt; 偏特化</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">myclass</span>(): <span class="built_in">m_i</span>(<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;myclass::myclass()偏特化版本执行了，this=&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot;  sizeof...(Other):&quot;</span>&lt;&lt;<span class="keyword">sizeof</span>...(Others)&lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 注意第二个参数，这是一个包的写法</span></span><br><span class="line">  <span class="built_in">myclass</span>(First partf, Others... paro):<span class="built_in">m_i</span>(partf), <span class="built_in">m_o</span>(paro...)</span><br><span class="line">  <span class="comment">//, myclass&lt;Others...&gt;(paro...)</span></span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;-----------------begin-------------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;myclass::myclass(First partf, Others... paro)执行了，this=&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;m_i = &quot;</span> &lt;&lt; m_i &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;------------------end--------------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  First m_i;</span><br><span class="line">  myclass&lt;Others...&gt; m_o;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myclass</span>&lt;&gt;<span class="comment">// 一个特殊化的版本，看起来像全特化，可变参模板不存在全特化</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">myclass</span>()</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;myclass::myclass()一个特殊化的版本执行了&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main中插入</span></span><br><span class="line"><span class="function">myclass&lt;<span class="type">int</span>, <span class="type">float</span>, <span class="type">double</span>&gt; <span class="title">myc</span><span class="params">(<span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">myclass::myclass()一个特殊化的版本执行了</span><br><span class="line">-----------------begin-------------------</span><br><span class="line">myclass::myclass(First partf, Others... paro)执行了，this=0x7fffae439fe0</span><br><span class="line">m_i = 14</span><br><span class="line">------------------end--------------------</span><br><span class="line">-----------------begin-------------------</span><br><span class="line">myclass::myclass(First partf, Others... paro)执行了，this=0x7fffae439fd8</span><br><span class="line">m_i = 13</span><br><span class="line">------------------end--------------------</span><br><span class="line">-----------------begin-------------------</span><br><span class="line">myclass::myclass(First partf, Others... paro)执行了，this=0x7fffae439fd0</span><br><span class="line">m_i = 12</span><br><span class="line">------------------end--------------------</span><br></pre></td></tr></table></figure></li>
<li>通过元组和递归调用展开参数包<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 元组的概念</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#include&lt;tuple&gt;</span></span><br><span class="line"><span class="comment">std::tuple&lt;float, int, int&gt; mytuple(12.5f, 100, 52);</span></span><br><span class="line"><span class="comment">std::cout &lt;&lt; std::get&lt;0&gt;(mytuple) &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">std::cout &lt;&lt; std::get&lt;2&gt;(mytuple) &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myfunctuple</span><span class="params">(<span class="type">const</span> tuple&lt;T...&gt;&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mian中插入</span></span><br><span class="line"><span class="built_in">myfunctuple</span>(mytuple);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类模板的泛化版本</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> mycount, <span class="type">int</span> mymaxcount, <span class="keyword">typename</span>... T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myclass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">mysfunc</span><span class="params">(<span class="type">const</span> tuple&lt;T...&gt;&amp; t)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>基类参数包的展开</li>
<li>特化</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++泛型</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言socket通信的基基础例子</title>
    <url>/Lei_Blog/2024/11/13/C%E8%AF%AD%E8%A8%80socket%E9%80%9A%E4%BF%A1%E7%9A%84%E5%9F%BA%E5%9F%BA%E7%A1%80%E4%BE%8B%E5%AD%90/</url>
    <content><![CDATA[<h2 id="socket通信基础"><a href="#socket通信基础" class="headerlink" title="socket通信基础"></a>socket通信基础</h2><h3 id="socket通信server端"><a href="#socket通信server端" class="headerlink" title="socket通信server端"></a>socket通信server端</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 5000		<span class="comment">//端口号</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BACKLOG 5	<span class="comment">//最大监听数</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> iSocketFD = <span class="number">0</span>;  <span class="comment">//socket句柄</span></span><br><span class="line">	<span class="type">int</span> iRecvLen = <span class="number">0</span>;   <span class="comment">//接收成功后的返回值</span></span><br><span class="line">	<span class="type">int</span> new_fd = <span class="number">0</span>; 	<span class="comment">//建立连接后的句柄</span></span><br><span class="line">	<span class="type">char</span> buf[<span class="number">4096</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">//</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">stLocalAddr</span> =</span> &#123;<span class="number">0</span>&#125;; <span class="comment">//本地地址信息结构图，下面有具体的属性赋值</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">stRemoteAddr</span> =</span> &#123;<span class="number">0</span>&#125;; <span class="comment">//对方地址信息</span></span><br><span class="line">	<span class="type">socklen_t</span> socklen = <span class="number">0</span>;  	</span><br><span class="line"> </span><br><span class="line">	iSocketFD = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>); <span class="comment">//建立socket</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="number">0</span> &gt; iSocketFD)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;创建socket失败！\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;	</span><br><span class="line"> </span><br><span class="line">	stLocalAddr.sin_family = AF_INET;  <span class="comment">/*该属性表示接收本机或其他机器传输*/</span></span><br><span class="line">	stLocalAddr.sin_port = htons(PORT); <span class="comment">/*端口号*/</span></span><br><span class="line">	stLocalAddr.sin_addr.s_addr=htonl(INADDR_ANY); <span class="comment">/*IP，括号内容表示本机IP*/</span></span><br><span class="line"> </span><br><span class="line">	<span class="comment">//绑定地址结构体和socket</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="number">0</span> &gt; bind(iSocketFD, (<span class="type">void</span> *)&amp;stLocalAddr, <span class="keyword">sizeof</span>(stLocalAddr)))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;绑定失败！\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//开启监听 ，第二个参数是最大监听数</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="number">0</span> &gt; listen(iSocketFD, BACKLOG))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;监听失败！\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;iSocketFD: %d\n&quot;</span>, iSocketFD);	</span><br><span class="line">	<span class="comment">//在这里阻塞知道接收到消息，参数分别是socket句柄，接收到的地址信息以及大小 </span></span><br><span class="line">	new_fd = accept(iSocketFD, (<span class="type">void</span> *)&amp;stRemoteAddr, &amp;socklen);</span><br><span class="line">	<span class="keyword">if</span>(<span class="number">0</span> &gt; new_fd)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;接收失败！\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;接收成功！\n&quot;</span>);</span><br><span class="line">		<span class="comment">//发送内容，参数分别是连接句柄，内容，大小，其他信息（设为0即可） </span></span><br><span class="line">		send(new_fd, <span class="string">&quot;这是服务器接收成功后发回的信息!&quot;</span>, <span class="keyword">sizeof</span>(<span class="string">&quot;这是服务器接收成功后发回的信息!&quot;</span>), <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;new_fd: %d\n&quot;</span>, new_fd);	</span><br><span class="line">	iRecvLen = recv(new_fd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);	</span><br><span class="line">	<span class="keyword">if</span>(<span class="number">0</span> &gt;= iRecvLen)    <span class="comment">//对端关闭连接 返回0</span></span><br><span class="line">	&#123;	</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;接收失败或者对端关闭连接！\n&quot;</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;buf: %s\n&quot;</span>, buf);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	close(new_fd);</span><br><span class="line">	close(iSocketFD);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="socket通信client端"><a href="#socket通信client端" class="headerlink" title="socket通信client端"></a>socket通信client端</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 5000			<span class="comment">//目标地址端口号</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADDR <span class="string">&quot;127.0.0.1&quot;</span> <span class="comment">//目标地址IP</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> iSocketFD = <span class="number">0</span>; <span class="comment">//socket句柄</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> iRemoteAddr = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">stRemoteAddr</span> =</span> &#123;<span class="number">0</span>&#125;; <span class="comment">//对端，即目标地址信息</span></span><br><span class="line">	<span class="type">socklen_t</span> socklen = <span class="number">0</span>;  	</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">4096</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">//存储接收到的数据</span></span><br><span class="line"> </span><br><span class="line">	iSocketFD = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>); <span class="comment">//建立socket</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="number">0</span> &gt; iSocketFD)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;创建socket失败！\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;	</span><br><span class="line"> </span><br><span class="line">	stRemoteAddr.sin_family = AF_INET;</span><br><span class="line">	stRemoteAddr.sin_port = htons(PORT);</span><br><span class="line">	inet_pton(AF_INET, ADDR, &amp;iRemoteAddr);</span><br><span class="line">	stRemoteAddr.sin_addr.s_addr=iRemoteAddr;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//连接方法： 传入句柄，目标地址，和大小</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="number">0</span> &gt; connect(iSocketFD, (<span class="type">void</span> *)&amp;stRemoteAddr, <span class="keyword">sizeof</span>(stRemoteAddr)))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;连接失败！\n&quot;</span>);</span><br><span class="line">		<span class="comment">//printf(&quot;connect failed:%d&quot;,errno);//失败时也可打印errno</span></span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;连接成功！\n&quot;</span>);</span><br><span class="line">		recv(iSocketFD, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>); <span class="comment">//将接收数据打入buf，参数分别是句柄，储存处，最大长度，其他信息（设为0即可）。 </span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Received:%s\n&quot;</span>, buf);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	close(iSocketFD);<span class="comment">//关闭socket	</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h3><p>  大端字节序，数据的低位字节存储到内存的高为字节，小端字节序是将数据的低位字节存储到内存的第位字节。其存储顺序是按字节顺序存储，不打乱每个字节位结构。</p>
<ul>
<li>在网络中传输的数据是以大端字节序传输的，称为网络字节序</li>
<li>在计算机中的数据时以小端的方式存在的，称为主机字节序<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;apra/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 端口IP转换</span></span><br><span class="line"><span class="comment">// 将主机字节序转为网络字节序</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">htons</span><span class="params">(<span class="type">uint16_t</span> hostshort)</span>;</span><br><span class="line"><span class="comment">// 将网络字节序转主机字节序</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">htonl</span><span class="params">(<span class="type">uint32_t</span> hostlong)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将网络字节序转主机字节序</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">ntohs</span><span class="params">(<span class="type">uint16_t</span> netshort)</span>;</span><br><span class="line"><span class="comment">// 将主机字节序转为网络字节序</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">ntohl</span><span class="params">(uint_32 netlong)</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="IP地址转换"><a href="#IP地址转换" class="headerlink" title="IP地址转换"></a>IP地址转换</h3><p>ip地址是一个整型数，当是平常运用socket通信的时候要使用字符串来进行描述，以此需要一个函数来对字符串地址转换为ip整型数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="comment">// *dest 转换为大端的网络字节数</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">af: 地址族协议，IPV4(AF_INET)/IPV6(AF_INET6)</span></span><br><span class="line"><span class="comment">src: ip地址： “192.168.1.100”</span></span><br><span class="line"><span class="comment">dst: 传出参数</span></span><br><span class="line"><span class="comment">返回值 1成功 -1失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_pton</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">void</span> *dest)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将网络字节数转换为主机字符串</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">af: 地址族协议</span></span><br><span class="line"><span class="comment">src: 为整型数对应的地址</span></span><br><span class="line"><span class="comment">size: 对应dst内存的大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="title function_">inet_ntop</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">void</span>* src, <span class="type">char</span>* dst, <span class="type">socklen_t</span> size)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//点分十进制ip-&gt; 网络字节数</span></span><br><span class="line"><span class="type">int_addr_t</span> <span class="title function_">inet_addr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cp)</span>;</span><br><span class="line"><span class="comment">// 网络字节数-&gt; 点分十进制ip</span></span><br><span class="line"><span class="type">char</span>* <span class="title function_">inet_ntoa</span><span class="params">(<span class="keyword">struct</span> in_addr in)</span>;</span><br></pre></td></tr></table></figure>
<h2 id="TCP通信流程"><a href="#TCP通信流程" class="headerlink" title="TCP通信流程"></a>TCP通信流程</h2><p>tcp是<em>面向连接</em>、<em>安全</em>，<em>流式传输</em>协议</p>
<ul>
<li>服务端<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">socket() -&gt; bind() -&gt; listen() -&gt; accept()[堵塞，等待客户端连接] -&gt; recv() -&gt;  send() -&gt; recv()[等待结束] -&gt; close()</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>客户端<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">socket() -&gt; connect() - &gt; send() -&gt; recv() - &gt; close()</span><br></pre></td></tr></table></figure></li>
<li>服务端代码  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// server.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建监听的套接字</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 将socket()返回值和本地的IP端口绑定到一起</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(<span class="number">10000</span>);   <span class="comment">// 大端端口</span></span><br><span class="line">    <span class="comment">// INADDR_ANY代表本机的所有IP, 假设有三个网卡就有三个IP地址</span></span><br><span class="line">    <span class="comment">// 这个宏可以代表任意一个IP地址</span></span><br><span class="line">    <span class="comment">// 这个宏一般用于本地的绑定操作</span></span><br><span class="line">    addr.sin_addr.s_addr = INADDR_ANY;  <span class="comment">// 这个宏的值为0 == 0.0.0.0</span></span><br><span class="line"><span class="comment">//    inet_pton(AF_INET, &quot;127.0.0.1&quot;, &amp;addr.sin_addr.s_addr);</span></span><br><span class="line">    <span class="type">int</span> ret = bind(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 设置监听</span></span><br><span class="line">    ret = listen(lfd, <span class="number">128</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 阻塞等待并接受客户端连接</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">    <span class="type">int</span> clilen = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">    <span class="type">int</span> cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;clilen);</span><br><span class="line">    <span class="keyword">if</span>(cfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打印客户端的地址信息</span></span><br><span class="line">    <span class="type">char</span> ip[<span class="number">24</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;客户端的IP地址: %s, 端口: %d\n&quot;</span>,</span><br><span class="line">        inet_ntop(AF_INET, &amp;cliaddr.sin_addr.s_addr, ip, <span class="keyword">sizeof</span>(ip)),</span><br><span class="line">        ntohs(cliaddr.sin_port));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 和客户端通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="type">int</span> len = read(cfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;客户端say: %s\n&quot;</span>, buf);</span><br><span class="line">            write(cfd, buf, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(len  == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;客户端断开了连接...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(cfd);</span><br><span class="line">    close(lfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>客户端代码  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// client.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建通信的套接字</span></span><br><span class="line">    <span class="type">int</span> fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 连接服务器</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(<span class="number">10000</span>);   <span class="comment">// 大端端口</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;addr.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = connect(fd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 和服务器端通信</span></span><br><span class="line">    <span class="type">int</span> number = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">&quot;你好, 服务器...%d\n&quot;</span>, number++);</span><br><span class="line">        write(fd, buf, <span class="built_in">strlen</span>(buf)+<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="type">int</span> len = read(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;服务器say: %s\n&quot;</span>, buf);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(len  == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;服务器断开了连接...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sleep(<span class="number">1</span>);   <span class="comment">// 每隔1s发送一条数据</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>多线程服务器  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">connect_info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> cfd;</span><br><span class="line">&#125; connect_info;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">worker</span><span class="params">(<span class="type">void</span> *args)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 5. 和客户端通信</span></span><br><span class="line">    connect_info *inf = (connect_info *)args;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="type">int</span> len = read(inf-&gt;cfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">if</span> (len &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;客户端say: %s\n&quot;</span>, buf);</span><br><span class="line">            write(inf-&gt;cfd, buf, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;客户端断开了连接...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(inf-&gt;cfd);</span><br><span class="line">    inf-&gt;cfd = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建监听的套接字</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (lfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 将socket()返回值和本地的IP端口绑定到一起</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(<span class="number">10000</span>); <span class="comment">// 大端端口</span></span><br><span class="line">    <span class="comment">// INADDR_ANY代表本机的所有IP, 假设有三个网卡就有三个IP地址</span></span><br><span class="line">    <span class="comment">// 这个宏可以代表任意一个IP地址</span></span><br><span class="line">    <span class="comment">// 这个宏一般用于本地的绑定操作</span></span><br><span class="line">    addr.sin_addr.s_addr = INADDR_ANY; <span class="comment">// 这个宏的值为0 == 0.0.0.0</span></span><br><span class="line">                                    <span class="comment">//    inet_pton(AF_INET, &quot;127.0.0.1&quot;, &amp;addr.sin_addr.s_addr);</span></span><br><span class="line">    <span class="type">int</span> ret = bind(lfd, (<span class="keyword">struct</span> sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 设置监听</span></span><br><span class="line">    ret = listen(lfd, <span class="number">128</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 阻塞等待并接受客户端连接</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> clilen = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line"></span><br><span class="line">    connect_info cf[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(cf) / <span class="keyword">sizeof</span>(connect_info); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cf[i].cfd = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;this is %d accept\n&quot;</span>, c++);</span><br><span class="line">        <span class="type">int</span> cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr *)&amp;cliaddr, &amp;clilen);</span><br><span class="line">        <span class="keyword">if</span> (cfd == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 打印客户端的地址信息</span></span><br><span class="line">        <span class="type">char</span> ip[<span class="number">24</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;客户端的IP地址: %s, 端口: %d\n&quot;</span>,</span><br><span class="line">            inet_ntop(AF_INET, &amp;cliaddr.sin_addr.s_addr, ip, <span class="keyword">sizeof</span>(ip)),</span><br><span class="line">            ntohs(cliaddr.sin_port));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt; <span class="keyword">sizeof</span>(cf)/<span class="keyword">sizeof</span>(connect_info);++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cf[i].cfd&lt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cf[i].cfd = cfd;</span><br><span class="line">                <span class="type">pthread_t</span> t;</span><br><span class="line">                pthread_create(&amp;t, <span class="literal">NULL</span>, worker, &amp;cf[i]);</span><br><span class="line">                pthread_detach(t);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(lfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>服务器通信</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt6_Charts_01</title>
    <url>/Lei_Blog/2024/11/07/Qt6-Charts-01/</url>
    <content><![CDATA[<h2 id="基本图表绘制"><a href="#基本图表绘制" class="headerlink" title="基本图表绘制"></a>基本图表绘制</h2><h3 id="配置设置"><a href="#配置设置" class="headerlink" title="配置设置"></a>配置设置</h3><p>cmake配置</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在配置中寻找关于chart的模块</span></span><br><span class="line"><span class="keyword">find_package</span>(Qt<span class="variable">$&#123;QT_VERSION_MAJOR&#125;</span> COMPONENTS Charts REQUIRED)</span><br><span class="line"><span class="comment"># 然后进行链接</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(QTchart_01 PRIVATE Qt<span class="variable">$&#123;QT_VERSION_MAJOR&#125;</span>::Charts)</span><br></pre></td></tr></table></figure>
<h3 id="QChartView"><a href="#QChartView" class="headerlink" title="QChartView"></a>QChartView</h3><p>QChart类主要是组织图表的内容（文档类），QChartView用于展示图表（视图类）。相当于画板和画板上的图像，两者要相互结合</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QChartView *chartview = <span class="keyword">new</span> <span class="built_in">QChartView</span>(<span class="keyword">this</span>);</span><br><span class="line">QChar *chart = <span class="keyword">new</span> <span class="built_in">QChart</span>();</span><br><span class="line">chart-&gt;<span class="built_in">setTitle</span>(<span class="string">&quot;chat01&quot;</span>);</span><br><span class="line"><span class="comment">// 将chart对象添加于chartview中</span></span><br><span class="line">chartview-&gt;<span class="built_in">setChart</span>(chart);</span><br><span class="line"><span class="comment">// 添加到父窗口中</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setCentralWidget</span>(chartview);</span><br></pre></td></tr></table></figure>
<h3 id="添加数值并绘制"><a href="#添加数值并绘制" class="headerlink" title="添加数值并绘制"></a>添加数值并绘制</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QLineSeries *series1 = <span class="keyword">new</span> <span class="built_in">QLineSeries</span>();</span><br><span class="line">series1-&gt;<span class="built_in">setName</span>(<span class="string">&quot;sin() line&quot;</span>);</span><br><span class="line"></span><br><span class="line">qreal t=<span class="number">0</span>, y1, y2, intv=<span class="number">0.1</span>;</span><br><span class="line"><span class="type">int</span> count = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;count; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    y1 = <span class="built_in">qSin</span>(t);</span><br><span class="line">    <span class="comment">// qDebug() &lt;&lt; y1;</span></span><br><span class="line">    series1-&gt;<span class="built_in">append</span>(t, y1);</span><br><span class="line">    t += intv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">chart-&gt;<span class="built_in">addSeries</span>(series1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建坐标轴</span></span><br><span class="line">QValueAxis *axisX = <span class="keyword">new</span> <span class="built_in">QValueAxis</span>();</span><br><span class="line">QValueAxis *axisY = <span class="keyword">new</span> <span class="built_in">QValueAxis</span>();</span><br><span class="line"><span class="comment">//设置范围</span></span><br><span class="line">axisX-&gt;<span class="built_in">setRange</span>(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">axisX-&gt;<span class="built_in">setTitleText</span>(<span class="string">&quot;x_zhou&quot;</span>);</span><br><span class="line">axisY-&gt;<span class="built_in">setRange</span>(<span class="number">-2</span>, <span class="number">2</span>);</span><br><span class="line">axisY-&gt;<span class="built_in">setTitleText</span>(<span class="string">&quot;value&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//坐标轴添加到图表，并指定方向</span></span><br><span class="line">chart-&gt;<span class="built_in">addAxis</span>(axisX,Qt::AlignBottom);</span><br><span class="line">chart-&gt;<span class="built_in">addAxis</span>(axisY,Qt::AlignLeft);</span><br><span class="line"><span class="comment">//同时将数值序列依附于XY轴</span></span><br><span class="line">series1-&gt;<span class="built_in">attachAxis</span>(axisX);</span><br><span class="line">series1-&gt;<span class="built_in">attachAxis</span>(axisY);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>QT6</category>
      </categories>
      <tags>
        <tag>qt6 chart</tag>
      </tags>
  </entry>
  <entry>
    <title>MarkDown语法</title>
    <url>/Lei_Blog/2024/11/01/MarkDown%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>MarkDown基础语法</p>
<h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>使用符号（#&#x2F;&#x3D;），最多支持六级标题，最好在符号后加上空格<br></p>
<ul>
<li># &emsp;一级标题<br></li>
<li>## &emsp;二级标题<br></li>
<li>### &emsp;三级标题<br></li>
</ul>
<h2 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h2><h3 id="语法如下"><a href="#语法如下" class="headerlink" title="语法如下"></a>语法如下</h3><ul>
<li>如果行与行之间没有空行则会被视为一段，若之间有有空行则视为不同段落</li>
<li>空行是指行内什么都没有，或只有空格和制表符</li>
<li>如果想在段内直接换行则需要在上一行的结尾插入两个以上的空格然后回车</li>
<li>当超过80个字符或以（。！?）等结尾时建议换行，或URL较长时换行</li>
</ul>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="有序列表语法如下"><a href="#有序列表语法如下" class="headerlink" title="有序列表语法如下"></a>有序列表语法如下</h3><ul>
<li>数字序号 + 英文句号 + 空格 + 列表内容     <ol>
<li>我是第一行</li>
<li>我是第二行</li>
<li>……..</li>
</ol>
</li>
<li>无序列表如下<br>*&#x2F;+&#x2F;- + 空格 + 列表内容</li>
</ul>
<h3 id="列表嵌套语法如下"><a href="#列表嵌套语法如下" class="headerlink" title="列表嵌套语法如下"></a>列表嵌套语法如下</h3><ul>
<li>- 第一层列表<br>tab + 第二层列表<br>tab+ tab + 第三层列表<br><br></li>
<li>第一层列表<ul>
<li>第二层列表<ul>
<li>第三层列表<ul>
<li>…..</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="图片插入"><a href="#图片插入" class="headerlink" title="图片插入"></a>图片插入</h2><h3 id="图片插入语法文字链接如下"><a href="#图片插入语法文字链接如下" class="headerlink" title="图片插入语法文字链接如下"></a>图片插入语法文字链接如下</h3><ul>
<li>![图片替代文字](图片替代地址)</li>
<li>[链接文字](链接地址)<ul>
<li>引用连接：<br><br>   [链接文字][链接标记]<br>   ……<br>   在底部:<br>   [链接标记]: 链接地址</li>
</ul>
</li>
</ul>
<h3 id="引用链接"><a href="#引用链接" class="headerlink" title="引用链接"></a>引用链接</h3><ul>
<li>链接标记可以有字母、数字、空格和标点符号</li>
<li>链接标记不区分大小写</li>
<li>定义的链接内容可以放在当前文件的任意位置、建议放在页尾巴</li>
<li>当链接地址为网络地址时要以http&#x2F;https开头，否则会被标识为本地地址</li>
</ul>
<h2 id="行内代码块"><a href="#行内代码块" class="headerlink" title="行内代码块"></a>行内代码块</h2><ul>
<li><p>行内代码引用要使用`包裹，语法如下<br>使用`cd..` -&gt; <code>CD .. </code> </p>
</li>
<li><p>代码块.TAB键或者4个空格开头</p>
<pre><code>  def test_print():
      pass
</code></pre>
</li>
</ul>
<h3 id="使用规范"><a href="#使用规范" class="headerlink" title="使用规范"></a>使用规范</h3><pre><code>    <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;aabb&quot;</span>)</span><br></pre></td></tr></table></figure>

    <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">include&lt;iostream&gt;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;test&quot;</span></span></span><br><span class="line">test</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">which</span> bash</span></span><br><span class="line">/bin/bash</span><br></pre></td></tr></table></figure>
</code></pre>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><h3 id="语法如下-1"><a href="#语法如下-1" class="headerlink" title="语法如下"></a>语法如下</h3><p>引用由&gt;+ 引用内容来标记</p>
<ul>
<li>多行引用也可以在每一行的开有都插入&gt;</li>
<li>在引用中可以嵌套引用</li>
<li>在引用中可以使用其它MarkDown语法</li>
<li>段落与换行的格式在引用中也是可以适用的<ul>
<li>示例    <blockquote>
<p>例子1   </p>
</blockquote>
 正常的句子<blockquote>
<p>多行引用第一行<br> 第二行</p>
</blockquote>
</li>
<li>引用嵌套<blockquote>
<p>引用嵌套 &gt;</p>
<blockquote>
<p>被嵌套部分 &gt;  &gt;</p>
</blockquote>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="GFM语法"><a href="#GFM语法" class="headerlink" title="GFM语法"></a>GFM语法</h2><h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><ul>
<li>~~被删除的文字~~<br><del>被删除的文字</del></li>
</ul>
<h3 id="表情符号"><a href="#表情符号" class="headerlink" title="表情符号"></a>表情符号</h3><ul>
<li>表情符号 :表情代码:<br>   :smile:<br>   :laughing:<br>   :+1:</li>
</ul>
<h3 id="自动链接"><a href="#自动链接" class="headerlink" title="自动链接"></a>自动链接</h3><ul>
<li>由&lt;&gt;包裹的URL地址被自动识别并解析为超链接<br>百度<a href="https://www.baidu.com/">https://www.baidu.com</a></li>
</ul>
<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><ul>
<li>表格语法如下     <br> 
\| 表头1 \| 表头2 \| 表头3 \|    
\|----  \|---- \| ----\|    
\| 内容1 \| 内容2\| 内容3\|   
<br>

<table>
<thead>
<tr>
<th>表头1</th>
<th>表头2</th>
<th>表头3</th>
</tr>
</thead>
<tbody><tr>
<td>内容1</td>
<td>内容2</td>
<td>内容3</td>
</tr>
<tr>
<td>内容1</td>
<td>内容2</td>
<td>内容3</td>
</tr>
</tbody></table>
</li>
<li>默认对齐<ul>
<li><p>左对齐【默认】 :</p>
</li>
<li><p>右对齐   -：</p>
</li>
<li><p>中间对齐 :-:    </p>
<p>中间对齐 |:—-:|:—-:|:—-:|     </p>
<table>
<thead>
<tr>
<th align="center">表头1</th>
<th align="center">表头2</th>
<th align="center">表头3</th>
</tr>
</thead>
<tbody><tr>
<td align="center">内容1</td>
<td align="center">内容2</td>
<td align="center">内容3</td>
</tr>
<tr>
<td align="center">内容1</td>
<td align="center">内容2</td>
<td align="center">内容3</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<h3 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h3><ul>
<li><p>任务列表以-+ 开头，由[+空格/X+]组成</p>
</li>
<li><p>X 可以有大小写,看编辑器支持，推荐小写，当中括号内为x时为选中状态    </p>
<ul>
<li><p><input checked="" disabled="" type="checkbox"> 
吃</p>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
喝</p>
</li>
<li><p><input disabled="" type="checkbox"> 
玩  </p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 吃 <ul>
<li><input disabled="" type="checkbox"> 吃鱼</li>
<li><input disabled="" type="checkbox"> 吃饭</li>
</ul>
</li>
</ul>
</li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- [x] 吃</span><br><span class="line">- [x] 喝</span><br><span class="line">- [ ] 玩  </span><br><span class="line"></span><br><span class="line">  - [x] 吃 </span><br><span class="line">    - [ ] 吃鱼</span><br><span class="line">    - [ ] 吃饭   </span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="锚点（书签）"><a href="#锚点（书签）" class="headerlink" title="锚点（书签）"></a>锚点（书签）</h3><p>[锚点描述](#锚点名)</p>
<ul>
<li>锚点名建议使用字母和数字，锚点名是区分大小写的</li>
<li>在锚点中不能含有空格也不能含有特殊字符<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[第一章](#第一章)</span><br><span class="line">[第二章](#第二章)</span><br></pre></td></tr></table></figure>

  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## 第一章</span><br><span class="line">baba baba baba</span><br><span class="line">## 第二章</span><br><span class="line">dcdc dcdc dcdc</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>async_相关示例</title>
    <url>/Lei_Blog/2024/11/13/async-%E7%9B%B8%E5%85%B3%E7%A4%BA%E4%BE%8B/</url>
    <content><![CDATA[<h2 id="future-promis-相关示例"><a href="#future-promis-相关示例" class="headerlink" title="future promis 相关示例"></a>future promis 相关示例</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)</span><br><span class="line">        r++;</span><br><span class="line">    std::cout &lt;&lt;std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">promise_future</span><span class="params">(std::promise&lt;<span class="type">int</span>&gt; f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;promise_future  &quot;</span>&lt;&lt;std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">    f.<span class="built_in">set_value</span>(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; fu = std::<span class="built_in">async</span>(std::launch::async, func);</span><br><span class="line">    <span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">()</span>&gt; <span class="title">task</span><span class="params">(func)</span></span>; <span class="comment">// 此时后台并未开辟线程 需要手动开启</span></span><br><span class="line">    <span class="keyword">auto</span> future_r = task.<span class="built_in">get_future</span>();</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(std::move(task))</span></span>; <span class="comment">// 若无这条，task.get_future().get() 会堵塞当前线程</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt;<span class="string">&quot;the p &quot;</span> &lt;&lt; <span class="built_in">func</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;the f &quot;</span> &lt;&lt; fu.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;tha pack &quot;</span> &lt;&lt; future_r.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// promise 是一个类模板，其通常与future,async一起使用，其作用是在一个线程中产生一个值在另外一个线程中获取这个值</span></span><br><span class="line">    std::promise&lt;<span class="type">int</span>&gt; f;</span><br><span class="line">    <span class="keyword">auto</span> f_future_promise = f.<span class="built_in">get_future</span>();</span><br><span class="line">    std::<span class="built_in">thread</span>(promise_future, std::<span class="built_in">move</span>(f)).<span class="built_in">join</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;promise future get  &quot;</span> &lt;&lt; f_future_promise.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++服务器多线程编程</tag>
      </tags>
  </entry>
  <entry>
    <title>c++线程池</title>
    <url>/Lei_Blog/2024/11/11/c-%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<h2 id="functional-bind-lambda"><a href="#functional-bind-lambda" class="headerlink" title="functional bind lambda"></a>functional bind lambda</h2><ul>
<li><p>测试示例1:functional bind</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassFunc</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Func</span><span class="params">(<span class="type">const</span> std::string &amp;s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; s &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> std::string &amp;s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; s &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Func_</span><span class="params">(<span class="type">const</span> std::string &amp;s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; s &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> std::string &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; s &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(Args... arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    (std::cout &lt;&lt; ... &lt;&lt; arg) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint_</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; b &lt;&lt; c &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">callableFunc</span> <span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span> </span>&#123;<span class="keyword">return</span> x/y;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;-----------------------functional-----------------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="function">std::function&lt;<span class="title">void</span><span class="params">(<span class="type">const</span> std::string &amp;)</span>&gt; <span class="title">func_1</span><span class="params">(func)</span></span>;</span><br><span class="line">    <span class="built_in">func_1</span>(<span class="string">&quot;func1&quot;</span>);</span><br><span class="line">    std::function&lt;<span class="type">void</span>(<span class="type">const</span> std::string &amp;)&gt; func_2 = func;</span><br><span class="line">    <span class="built_in">func_2</span>(<span class="string">&quot;func2&quot;</span>);</span><br><span class="line">    <span class="comment">// std::function&lt;void(const std::string &amp;)&gt; func_3(ClassFunc()) 不可以</span></span><br><span class="line"></span><br><span class="line">    std::function&lt;<span class="type">void</span>(<span class="type">const</span> std::string &amp;)&gt; func_3 = <span class="built_in">ClassFunc</span>();</span><br><span class="line">    <span class="built_in">func_3</span>(<span class="string">&quot;func3&quot;</span>);</span><br><span class="line">    <span class="comment">// std::function&lt;void(const std::string &amp;)&gt; func_4(ClassFunc); 不可以 funnction 要包装可调用对象</span></span><br><span class="line">    <span class="comment">// func_4(&quot;Hello&quot;);</span></span><br><span class="line">    <span class="keyword">auto</span> func_lambda = [](<span class="type">const</span> std::string &amp;s)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; s &lt;&lt; std::endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">std::function&lt;<span class="title">void</span><span class="params">(<span class="type">const</span> std::string &amp;)</span>&gt; <span class="title">func_4</span><span class="params">(func_lambda)</span></span>;</span><br><span class="line">    <span class="built_in">func_4</span>(<span class="string">&quot;func4&quot;</span>);</span><br><span class="line">    std::function&lt;<span class="type">void</span>(<span class="type">const</span> std::string &amp;)&gt; func_5 = func_lambda;</span><br><span class="line">    <span class="built_in">func_5</span>(<span class="string">&quot;func5&quot;</span>);</span><br><span class="line"></span><br><span class="line">    std::function&lt;<span class="type">void</span>(<span class="type">const</span> std::string &amp;)&gt; func_6 = ClassFunc::Func;</span><br><span class="line">    <span class="built_in">func_6</span>(<span class="string">&quot;func6&quot;</span>);</span><br><span class="line">    <span class="function">std::function&lt;<span class="title">void</span><span class="params">(<span class="type">const</span> std::string &amp;)</span>&gt; <span class="title">func_7</span><span class="params">(ClassFunc::Func)</span></span>;</span><br><span class="line">    <span class="built_in">func_7</span>(<span class="string">&quot;func7&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ClassFunc cf;</span><br><span class="line">    <span class="function">std::function&lt;<span class="title">void</span><span class="params">(ClassFunc*, <span class="type">const</span> std::string &amp;)</span>&gt; <span class="title">func_8</span><span class="params">(&amp;ClassFunc::Func_)</span></span>;</span><br><span class="line">    <span class="built_in">func_8</span>(&amp;cf, <span class="string">&quot;func8&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;-----------------------functional-----------------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;--------------------------bind--------------------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::function&lt;<span class="type">void</span>()&gt; func_b1 = std::<span class="built_in">bind</span>(func,<span class="string">&quot;func_b1&quot;</span>);</span><br><span class="line">    <span class="built_in">func_b1</span>();</span><br><span class="line">    std::function&lt;<span class="type">void</span>()&gt; func_b2 = std::<span class="built_in">bind</span>(func_1,<span class="string">&quot;func_b2&quot;</span>);</span><br><span class="line">    <span class="built_in">func_b2</span>();</span><br><span class="line">    std::function&lt;<span class="type">void</span>()&gt; func_b3 = std::<span class="built_in">bind</span>(func_2,<span class="string">&quot;func_b3&quot;</span>);</span><br><span class="line">    <span class="built_in">func_b3</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">myPrint</span>(<span class="string">&quot;sss&quot;</span>, <span class="number">1234</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    <span class="keyword">auto</span> NewCallable = std::<span class="built_in">bind</span>(callableFunc, std::placeholders::_1,<span class="number">2</span>);  </span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">NewCallable</span>(<span class="number">10</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">// std::function&lt;void(int, int, int)&gt; func_b3 = std::bind(myPrint&lt;int, int, int&gt;, std::placeholders::_1, 2);</span></span><br><span class="line">    <span class="comment">// auto func_b4 = std::bind(myPrint_, std::placeholders::_1, 3);</span></span><br><span class="line">    <span class="built_in">myPrint_</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;--------------------------bind--------------------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>测试示例2</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> Compare&gt;</span><br><span class="line"><span class="function">Iterator <span class="title">my_find_if</span><span class="params">(Iterator first, Iterator last, Compare comp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; first != last; ++first)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">comp</span>(*first))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Compare, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">_myBind1st</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    _myBind1st(Compare comp, T val) : _comp(comp), <span class="built_in">val</span>(val) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T &amp;second)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _comp(val, second);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Compare _comp;</span><br><span class="line">    T val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Compare, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">_myBind1st&lt;Compare, T&gt; <span class="title">myBind1st</span><span class="params">(Compare comp, <span class="type">const</span> T &amp;val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _myBind1st&lt;Compare, T&gt;(comp, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Container&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showContainer</span><span class="params">(Container &amp;c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typename</span> Container::iterator i = c.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">for</span> (; i != c.<span class="built_in">end</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(<span class="built_in">rand</span>() % <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">showContainer</span>(vec);</span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">showContainer</span>(vec);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;using greater&lt;int&gt;()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// greater&lt;int&gt;() less&lt;int&gt;() 二元函数对象</span></span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    <span class="built_in">showContainer</span>(vec);</span><br><span class="line">    <span class="comment">// 按序插入70到vec中 找到小于70的数，在之前插入</span></span><br><span class="line">    <span class="comment">// 此处需要一个一元函数对象</span></span><br><span class="line">    <span class="keyword">auto</span> it1 = <span class="built_in">find_if</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="built_in">bind2nd</span>(<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;(), <span class="number">80</span>));</span><br><span class="line">    <span class="keyword">if</span> (it1 != vec.<span class="built_in">end</span>())</span><br><span class="line">        vec.<span class="built_in">insert</span>(it1, <span class="number">70</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;insert 70&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">showContainer</span>(vec);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;using my_find_if&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">auto</span> cmp_l = [](<span class="type">int</span> i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">70</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> it2 = <span class="built_in">my_find_if</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [](<span class="type">int</span> i)</span><br><span class="line">                        &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">80</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; &#125;);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;insert 80&quot;</span> &lt;&lt; endl;</span><br><span class="line">    vec.<span class="built_in">insert</span>(it2, <span class="number">80</span>);</span><br><span class="line">    <span class="built_in">showContainer</span>(vec);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot;insert 30&quot; &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// auto it3 = my_find_if(vec.begin(), vec.end(), bind2nd([](int a, int b)</span></span><br><span class="line">    <span class="comment">//                                                       &#123;</span></span><br><span class="line">    <span class="comment">//     if(a&lt;b)</span></span><br><span class="line">    <span class="comment">//         return true;</span></span><br><span class="line">    <span class="comment">//     return false; &#125;, 30));</span></span><br><span class="line">    <span class="comment">// vec.insert(it3, 30);</span></span><br><span class="line">    <span class="comment">// showContainer(vec);</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;insert 20&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// auto it4 = my_find_if(vec.begin(), vec.end(), myBind1st(greater&lt;int&gt;(),20));</span></span><br><span class="line">    <span class="keyword">auto</span> it4 = <span class="built_in">my_find_if</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="built_in">myBind1st</span>([](<span class="type">const</span> <span class="type">int</span> &amp;a, <span class="type">const</span> <span class="type">int</span> &amp;b)</span><br><span class="line">                                                            &#123;</span><br><span class="line">        <span class="keyword">if</span>(a&gt;b)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; &#125;, <span class="number">20</span>));</span><br><span class="line">    vec.<span class="built_in">insert</span>(it4, <span class="number">20</span>);</span><br><span class="line">    <span class="built_in">showContainer</span>(vec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试示例3：</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Ty&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyFunc</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span>... T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyFunc</span>&lt;<span class="built_in">R</span>(T...)&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> PFUNC = <span class="built_in">R</span> (*)(T...);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyFunc</span>(PFUNC f) : _func(f) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">R <span class="title">operator</span><span class="params">()</span><span class="params">(T... Args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _func(Args...);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    PFUNC _func;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> string <span class="title">getStringPrint</span><span class="params">(<span class="type">const</span> string&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="function">MyFunc&lt;<span class="title">int</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>&gt; <span class="title">f</span><span class="params">(sum)</span></span>;</span><br><span class="line">    <span class="built_in">f</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="function">MyFunc&lt;<span class="type">const</span> <span class="title">string</span><span class="params">(<span class="type">const</span> string &amp;)</span>&gt; <span class="title">f2</span><span class="params">(getStringPrint)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> a = <span class="built_in">f2</span>(s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="一个线程池例子"><a href="#一个线程池例子" class="headerlink" title="一个线程池例子"></a>一个线程池例子</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ThreadPool</span>(<span class="type">unsigned</span> <span class="type">int</span> numThread) : <span class="built_in">threadNum</span>(numThread), <span class="built_in">stop</span>(<span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; threadNum; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            threads.<span class="built_in">emplace_back</span>([<span class="keyword">this</span>]</span><br><span class="line">                                 &#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="number">1</span>) <span class="comment">// 每个线程里面放置的都是循环体</span></span><br><span class="line">                &#123;</span><br><span class="line">                    std::unique_lock&lt;std::mutex&gt; <span class="built_in">lock</span>(_mtx);</span><br><span class="line">                    condition.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]&#123;</span><br><span class="line">                        <span class="keyword">return</span> !tasks.<span class="built_in">empty</span>() || stop;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    <span class="keyword">if</span>(stop &amp;&amp; tasks.<span class="built_in">empty</span>()) <span class="comment">// 如果任务队列都为空 且线程池时关闭状态</span></span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    <span class="comment">// 取出一个被包装好的任务</span></span><br><span class="line">                    std::function&lt;<span class="built_in">void</span>(<span class="type">void</span>)&gt; task = std::<span class="built_in">move</span>(tasks.<span class="built_in">front</span>());</span><br><span class="line">                    tasks.<span class="built_in">pop</span>();</span><br><span class="line">                    lock.<span class="built_in">unlock</span>();</span><br><span class="line">                    <span class="built_in">task</span>();</span><br><span class="line">                &#125; &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">ThreadPool</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;delete thread pool&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_mtx)</span></span>;</span><br><span class="line">            stop = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        condition.<span class="built_in">notify_all</span>(); <span class="comment">// 通知所有线程去完成任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;t : threads)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 取出所有任务，让正在运行的线程停止</span></span><br><span class="line">            t.<span class="built_in">join</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">enqueue</span><span class="params">(F &amp;&amp;f, Args &amp;&amp;...args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::function&lt;<span class="type">void</span>(<span class="type">void</span>)&gt; task = std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...);</span><br><span class="line">        tasks.<span class="built_in">emplace</span>(std::<span class="built_in">move</span>(task));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> threadNum;</span><br><span class="line">    <span class="type">bool</span> stop;</span><br><span class="line">    std::queue&lt;std::function&lt;<span class="type">void</span>(<span class="type">void</span>)&gt;&gt; tasks;</span><br><span class="line">    std::vector&lt;std::thread&gt; threads;</span><br><span class="line">    std::mutex _mtx;</span><br><span class="line">    std::condition_variable condition;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sayHello</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> t, std::string &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; t; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line">        std::cout &lt;&lt; s &lt;&lt; <span class="string">&quot;  this thread num: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string s1 = <span class="string">&quot;nihao 1&quot;</span>;</span><br><span class="line">    std::string s2 = <span class="string">&quot;nihao 2&quot;</span>;</span><br><span class="line">    std::string s3 = <span class="string">&quot;nihao 3&quot;</span>;</span><br><span class="line">    std::string s4 = <span class="string">&quot;nihao 4&quot;</span>;</span><br><span class="line">    std::string s5 = <span class="string">&quot;nihao 5&quot;</span>;</span><br><span class="line">    std::string s6 = <span class="string">&quot;nihao 6&quot;</span>;</span><br><span class="line">    std::string s7 = <span class="string">&quot;nihao 7&quot;</span>;</span><br><span class="line">    <span class="comment">// sayHello(3, s);</span></span><br><span class="line">    <span class="function">ThreadPool <span class="title">tpl</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">    tpl.<span class="built_in">enqueue</span>(sayHello, <span class="number">3</span>, s1);</span><br><span class="line">    tpl.<span class="built_in">enqueue</span>(sayHello, <span class="number">3</span>, s2);</span><br><span class="line">    tpl.<span class="built_in">enqueue</span>(sayHello, <span class="number">3</span>, s3);</span><br><span class="line">    <span class="comment">// std::this_thread::sleep_for(std::chrono::seconds(10));</span></span><br><span class="line">    tpl.<span class="built_in">enqueue</span>(sayHello, <span class="number">3</span>, s4);</span><br><span class="line">    tpl.<span class="built_in">enqueue</span>(sayHello, <span class="number">3</span>, s5);</span><br><span class="line">    tpl.<span class="built_in">enqueue</span>(sayHello, <span class="number">3</span>, s6);</span><br><span class="line">    tpl.<span class="built_in">enqueue</span>(sayHello, <span class="number">3</span>, s7);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;all task has enqeued... please wait...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++池结构</tag>
      </tags>
  </entry>
  <entry>
    <title>epoll相关内容</title>
    <url>/Lei_Blog/2024/11/14/epoll%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/</url>
    <content><![CDATA[<h2 id="epoll-简要说明"><a href="#epoll-简要说明" class="headerlink" title="epoll 简要说明"></a>epoll 简要说明</h2><p><a href="https://subingwen.cn/linux/epoll/">相关连接</a><br>epoll 全称 eventpoll，是 linux 内核实现IO多路转接&#x2F;复用（IO multiplexing）的一个实现。IO多路转接的意思是在一个操作里同时监听多个输入输出源，在其中一个或多个输入输出源可用的时候返回，然后对其的进行读写操作。epoll是select和poll的升级版，相较于这两个前辈，epoll改进了工作方式，因此它更加高效。</p>
<ul>
<li>对于待检测集合select和poll是基于线性方式处理的，epoll是基于红黑树来管理待检测集合的。</li>
<li>select和poll每次都会线性扫描整个待检测集合，集合越大速度越慢，epoll使用的是回调机制，效率高，处理效率也不会随着检测集合的变大而下降</li>
<li>select和poll工作过程中存在内核&#x2F;用户空间数据的频繁拷贝问题，在epoll中内核和用户区使用的是共享内存（基于mmap内存映射区实现），省去了不必要的内存拷贝。</li>
<li>程序猿需要对select和poll返回的集合进行判断才能知道哪些文件描述符是就绪的，通过epoll可以直接得到已就绪的文件描述符集合，无需再次检测</li>
<li>使用epoll没有最大文件描述符的限制，仅受系统中进程能打开的最大文件数目限制</li>
</ul>
<p>当多路复用的文件数量庞大、IO流量频繁的时候，一般不太适合使用select()和poll()，这种情况下select()和poll()表现较差，推荐使用epoll()。</p>
<h2 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="comment">// 创建epoll实例，通过一棵红黑树管理待检测集合</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>;</span><br><span class="line"><span class="comment">// 管理红黑树上的文件描述符(添加、修改、删除)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span>;</span><br><span class="line"><span class="comment">// 检测epoll树中是否有就绪的文件描述符</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event * events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure>
<p>select&#x2F;poll低效的原因之一是将“添加&#x2F;维护待检测任务”和“阻塞进程&#x2F;线程”两个步骤合二为一。每次调用select都需要这两步操作，然而大多数应用场景中，需要监视的socket个数相对固定，并不需要每次都修改。epoll将这两个操作分开，先用epoll_ctl()维护等待队列，再调用epoll_wait()阻塞进程（解耦）。通过下图的对比显而易见，epoll的效率得到了提升。</p>
<pre class="mermaid">flowchart LR
    A(添加带检测任务 epoll_ctrl) --> B(堵塞 epoll_wait) --> c[...]--> d(堵塞 epoll_wait) --> e[...]</pre>
<ul>
<li>epoll_create()函数的作用是创建一个红黑树模型的实例，用于管理待检测的文件描述符的集合。  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数参数 size：在Linux内核2.6.8版本以后，这个参数是被忽略的，只需要指定一个大于0的数值就可以了。</span></span><br><span class="line"><span class="comment">函数返回值：</span></span><br><span class="line"><span class="comment">失败：返回-1</span></span><br><span class="line"><span class="comment">成功：返回一个有效的文件描述符，通过这个文件描述符就可以访问创建的epoll实例了</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>epoll_ctl()函数的作用是管理红黑树实例上的节点，可以进行添加、删除、修改操作。  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 联合体, 多个变量共用同一块内存        </span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数参数：</span></span><br><span class="line"><span class="comment">epfd：epoll_create() 函数的返回值，通过这个参数找到epoll实例</span></span><br><span class="line"><span class="comment">op：这是一个枚举值，控制通过该函数执行什么操作</span></span><br><span class="line"><span class="comment">EPOLL_CTL_ADD：往epoll模型中添加新的节点</span></span><br><span class="line"><span class="comment">EPOLL_CTL_MOD：修改epoll模型中已经存在的节点</span></span><br><span class="line"><span class="comment">EPOLL_CTL_DEL：删除epoll模型中的指定的节点</span></span><br><span class="line"><span class="comment">fd：文件描述符，即要添加/修改/删除的文件描述符</span></span><br><span class="line"><span class="comment">event：epoll事件，用来修饰第三个参数对应的文件描述符的，指定检测这个文件描述符的什么事件</span></span><br><span class="line"><span class="comment">events：委托epoll检测的事件</span></span><br><span class="line"><span class="comment">EPOLLIN：读事件, 接收数据, 检测读缓冲区，如果有数据该文件描述符就绪</span></span><br><span class="line"><span class="comment">EPOLLOUT：写事件, 发送数据, 检测写缓冲区，如果可写该文件描述符就绪</span></span><br><span class="line"><span class="comment">EPOLLERR：异常事件</span></span><br><span class="line"><span class="comment">data：用户数据变量，这是一个联合体类型，通常情况下使用里边的fd成员，用于存储待检测的文件描述符的值，在调用epoll_wait()函数的时候这个值会被传出。</span></span><br><span class="line"><span class="comment">函数返回值：</span></span><br><span class="line"><span class="comment">失败：返回-1</span></span><br><span class="line"><span class="comment">成功：返回0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> &#123;</span></span><br><span class="line">    <span class="type">void</span>        *ptr;</span><br><span class="line">    <span class="type">int</span>          fd;	<span class="comment">// 通常情况下使用这个成员, 和epoll_ctl的第三个参数相同即可</span></span><br><span class="line">    <span class="type">uint32_t</span>     u32;</span><br><span class="line">    <span class="type">uint64_t</span>     u64;</span><br><span class="line">&#125; <span class="type">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span>     events;      <span class="comment">/* Epoll events */</span></span><br><span class="line">    <span class="type">epoll_data_t</span> data;        <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span>;</span><br></pre></td></tr></table></figure></li>
<li>epoll_wait()函数的作用是检测创建的epoll实例中有没有就绪的文件描述符。  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">函数参数：</span></span><br><span class="line"><span class="comment">epfd：epoll_create() 函数的返回值, 通过这个参数找到epoll实例</span></span><br><span class="line"><span class="comment">events：传出参数, 这是一个结构体数组的地址, 里边存储了已就绪的文件描述符的信息</span></span><br><span class="line"><span class="comment">maxevents：修饰第二个参数, 结构体数组的容量（元素个数）</span></span><br><span class="line"><span class="comment">timeout：如果检测的epoll实例中没有已就绪的文件描述符，该函数阻塞的时长, 单位ms 毫秒</span></span><br><span class="line"><span class="comment">0：函数不阻塞，不管epoll实例中有没有就绪的文件描述符，函数被调用后都直接返回</span></span><br><span class="line"><span class="comment">大于0：如果epoll实例中没有已就绪的文件描述符，函数阻塞对应的毫秒数再返回</span></span><br><span class="line"><span class="comment">-1：函数一直阻塞，直到epoll实例中有已就绪的文件描述符之后才解除阻塞</span></span><br><span class="line"><span class="comment">函数返回值：</span></span><br><span class="line"><span class="comment">成功：</span></span><br><span class="line"><span class="comment">等于0：函数是阻塞被强制解除了, 没有检测到满足条件的文件描述符</span></span><br><span class="line"><span class="comment">大于0：检测到的已就绪的文件描述符的总个数</span></span><br><span class="line"><span class="comment">失败：返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event * events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="epoll的使用流程"><a href="#epoll的使用流程" class="headerlink" title="epoll的使用流程"></a>epoll的使用流程</h2><pre class="mermaid">flowchart TD
    A[创建监听的套接字] --> B[设置端口复用（可选）] --> C[使用本地的IP与端口和监听的套接字进行绑定] --> D[给监听的套接字设置监听] --> E[创建epoll实例对象] 
    F[将用于监听的套接字添加到epoll实例中] --> G[检测添加到epoll实例中的文件描述符是否已就绪]-->G</pre>
<ul>
<li>示例代码  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// server</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建监听套接字</span></span><br><span class="line">    <span class="type">int</span> sfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == sfd)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket fd create&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设定绑定信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in));</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    <span class="comment">// 设置端口复用</span></span><br><span class="line">    <span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line">    setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="keyword">sizeof</span>(opt));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定端口</span></span><br><span class="line">    <span class="type">int</span> ret = bind(sfd, (<span class="keyword">struct</span> sockaddr *)&amp;server_addr, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in));</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == ret)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind &quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置监听数量</span></span><br><span class="line">    ret = listen(sfd, <span class="number">64</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == ret)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen &quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建epoll</span></span><br><span class="line">    <span class="type">int</span> epfd = epoll_create(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == epfd)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll create &quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// epoll节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">    <span class="comment">// 检测socket fd 中是否有数据</span></span><br><span class="line">    ev.events = EPOLLIN;</span><br><span class="line">    ev.data.fd = sfd;</span><br><span class="line">    <span class="comment">// 在一个epoll对象中添加一个epoll节点， 监控相应事件</span></span><br><span class="line">    ret = epoll_ctl(epfd, EPOLL_CTL_ADD, sfd, &amp;ev);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == ret)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll_ctl &quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">evs</span>[1024];</span></span><br><span class="line">    <span class="type">int</span> size = <span class="keyword">sizeof</span>(evs) / <span class="keyword">sizeof</span>(<span class="keyword">struct</span> epoll_event);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 持续检测</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 堵塞 等待事件 有事件立即返回</span></span><br><span class="line">        <span class="type">int</span> num = epoll_wait(epfd, evs, size, <span class="number">-1</span>);</span><br><span class="line">        <span class="comment">// 遍历事件</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> curfd = evs[i].data.fd;</span><br><span class="line">            <span class="comment">// 判断是不是监听socket文件描述符</span></span><br><span class="line">            <span class="keyword">if</span> (curfd == sfd)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 说明有连接过来</span></span><br><span class="line">                <span class="type">int</span> cfd = accept(curfd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">                <span class="comment">// 将新文件描述符添至epoll对象中下次轮询处理</span></span><br><span class="line">                ev.events = EPOLLIN;</span><br><span class="line">                ev.data.fd = cfd;</span><br><span class="line">                ret = epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &amp;ev);</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">-1</span> == ret)</span><br><span class="line">                &#123;</span><br><span class="line">                    perror(<span class="string">&quot;epoll_ctl add in for loop&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 处理通信描述符</span></span><br><span class="line">                <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">                <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                <span class="type">int</span> len = recv(curfd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">0</span> == len)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;客户端断开连接\n&quot;</span>);</span><br><span class="line">                    <span class="comment">// 删除对应描述符</span></span><br><span class="line">                    epoll_ctl(epfd, EPOLL_CTL_DEL, curfd, <span class="literal">NULL</span>);</span><br><span class="line">                    close(curfd);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (len &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;客户端发送：%s\n&quot;</span>, buf);</span><br><span class="line">                    send(curfd, buf, len, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    perror(<span class="string">&quot;recv err&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    epoll_ctl(epfd,EPOLL_CTL_DEL, sfd, <span class="literal">NULL</span>);</span><br><span class="line">    close(sfd);</span><br><span class="line">    close(epfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  client  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 9999        <span class="comment">// 目标地址端口号</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADDR <span class="string">&quot;127.0.0.1&quot;</span> <span class="comment">// 目标地址IP</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == sfd)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket creat&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(PORT);</span><br><span class="line">    inet_pton(sfd, ADDR, &amp;addr.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = connect(sfd, (<span class="keyword">struct</span> sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in));</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == ret)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;connect &quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 和服务端通信</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">&quot;你好服务器\n&quot;</span>);</span><br><span class="line">        write(sfd, buf, <span class="built_in">strlen</span>(buf) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="type">int</span> len = read(sfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">if</span> (len &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;服务器： %s\n&quot;</span>, buf);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;服务器断开连接！\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(sfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>服务器通信</tag>
      </tags>
  </entry>
  <entry>
    <title>test</title>
    <url>/Lei_Blog/2024/11/01/test/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>vsftpd简单安装和使用</title>
    <url>/Lei_Blog/2024/11/03/vsftpd%E7%AE%80%E5%8D%95%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="Ubuntu系统FTP服务器搭建"><a href="#Ubuntu系统FTP服务器搭建" class="headerlink" title="Ubuntu系统FTP服务器搭建"></a>Ubuntu系统FTP服务器搭建</h2><h3 id="安装vsftpd软件"><a href="#安装vsftpd软件" class="headerlink" title="安装vsftpd软件"></a>安装vsftpd软件</h3><p><a href="https://www.cnblogs.com/HOsystem/p/16629572.html">详细配置说明链接</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install vsftpd</span><br><span class="line"> </span><br><span class="line"># 设置开机启动并启动ftp服务</span><br><span class="line">systemctl enable vsftpd</span><br><span class="line">systemctl start vsftpd</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查看其运行状态</span><br><span class="line">systemctl  status vsftpd</span><br><span class="line">#重启服务</span><br><span class="line">systemctl  restart vsftpd</span><br></pre></td></tr></table></figure>

<h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo useradd -d /home/ftp/ftp_root -m ftpadmin</span><br><span class="line">sudo passwd ftpadmin</span><br><span class="line">输入密码：</span><br><span class="line">再次输入密码：</span><br><span class="line">chmod -R 777 /home/ftp/ftp_root</span><br></pre></td></tr></table></figure>

<h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo nano /etc/vsftpd.conf</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">存在的修改成酱紫：</span><br><span class="line">listen=NO # 阻止 vsftpd 在独立模式下运行</span><br><span class="line">listen_ipv6=YES # vsftpd 将监听 ipv6 而不是 IPv4，你可以根据你的网络情况设置</span><br><span class="line">anonymous_enable=NO # 关闭匿名登录</span><br><span class="line">local_enable=YES # 允许本地用户登录</span><br><span class="line">write_enable=YES # 启用可以修改文件的 FTP 命令</span><br><span class="line">local_umask=022 # 本地用户创建文件的 umask 值</span><br><span class="line">dirmessage_enable=YES # 当用户第一次进入新目录时显示提示消息</span><br><span class="line">xferlog_enable=YES # 一个存有详细的上传和下载信息的日志文件</span><br><span class="line">connect_from_port_20=YES # 在服务器上针对 PORT 类型的连接使用端口 20（FTP 数据）</span><br><span class="line">xferlog_std_format=YES # 保持标准日志文件格式</span><br><span class="line">pam_service_name=vsftpd # vsftpd 将使用的 PAM 验证设备的名字</span><br></pre></td></tr></table></figure>
<p>修改配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/etc/vsftpd.conf </span><br><span class="line">将pam_service_name=vsftpd   修改为：pam_service_name=ftp</span><br></pre></td></tr></table></figure>
<p>最后添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">userlist_deny=NO</span><br><span class="line">userlist_enable=YES</span><br><span class="line">userlist_file=/etc/vsftpd.allowed_users</span><br><span class="line"></span><br><span class="line">nano /etc/vsftpd.chroot_list</span><br><span class="line">#输入ftpadmin后保存退出</span><br><span class="line">开启端口 数据传输20 命令交互21</span><br><span class="line">sudo ufw allow 20</span><br><span class="line">sudo ufw allow 21</span><br><span class="line">#重启服务</span><br><span class="line">systemctl start vsftpd</span><br></pre></td></tr></table></figure>


<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ftp localhost</span></span><br><span class="line">Connected to localhost.</span><br><span class="line">500 OOPS: cannot read user list file:/etc/vsftpd.allowed_users</span><br><span class="line"><span class="meta prompt_">ftp&gt; </span><span class="language-bash"><span class="built_in">exit</span></span></span><br></pre></td></tr></table></figure>
<h2 id="远程登陆"><a href="#远程登陆" class="headerlink" title="远程登陆"></a>远程登陆</h2><h3 id="安装filezilla"><a href="#安装filezilla" class="headerlink" title="安装filezilla"></a>安装filezilla</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install filezilla</span><br></pre></td></tr></table></figure>
<p>输入相关选项即可连接</p>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>vsftpd</tag>
      </tags>
  </entry>
  <entry>
    <title>boost_asio网络编程</title>
    <url>/Lei_Blog/2024/11/23/boost-asio%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="asio相关接口说明"><a href="#asio相关接口说明" class="headerlink" title="asio相关接口说明"></a>asio相关接口说明</h2><ul>
<li>代码示例  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @Author: LeiJiulong</span></span><br><span class="line"><span class="comment">* @Date: 2024-11-17 08:32:01</span></span><br><span class="line"><span class="comment">* @LastEditors: LeiJiulong &amp;&amp; lei15557570906@outlook.com</span></span><br><span class="line"><span class="comment">* @LastEditTime: 2024-11-17 08:48:56</span></span><br><span class="line"><span class="comment">* @Description:</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内容地址：https://llfc.club/category?catid=225RaiVNI8pFDD5L4m807g7ZwmF#!aid/2LfzYBkRCfdEDrtE6hWz8VrCLoS</span></span><br><span class="line"><span class="comment">// 端点创建</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">client_end_point</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Step 1. Assume that the client application has already</span></span><br><span class="line">    <span class="comment">// obtained the IP-address and the protocol port number.</span></span><br><span class="line">    std::string raw_ip_address = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> port_num = <span class="number">3333</span>;</span><br><span class="line">    <span class="comment">// Used to store information about error that happens</span></span><br><span class="line">    <span class="comment">// while parsing the raw IP-address.</span></span><br><span class="line">    boost::system::error_code ec;</span><br><span class="line">    <span class="comment">// Step 2. Using IP protocol version independent address</span></span><br><span class="line">    <span class="comment">// representation.</span></span><br><span class="line">    asio::ip::address ip_address =</span><br><span class="line">        asio::ip::address::<span class="built_in">from_string</span>(raw_ip_address, ec);</span><br><span class="line">    <span class="keyword">if</span> (ec.<span class="built_in">value</span>() != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Provided IP address is invalid. Breaking execution.</span></span><br><span class="line">        std::cout</span><br><span class="line">            &lt;&lt; <span class="string">&quot;Failed to parse the IP address. Error code = &quot;</span></span><br><span class="line">            &lt;&lt; ec.<span class="built_in">value</span>() &lt;&lt; <span class="string">&quot;. Message: &quot;</span> &lt;&lt; ec.<span class="built_in">message</span>();</span><br><span class="line">        <span class="keyword">return</span> ec.<span class="built_in">value</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Step 3.</span></span><br><span class="line">    asio::ip::<span class="function">tcp::endpoint <span class="title">ep</span><span class="params">(ip_address, port_num)</span></span>;</span><br><span class="line">    <span class="comment">// Step 4. The endpoint is ready and can be used to specify a</span></span><br><span class="line">    <span class="comment">// particular server in the network the client wants to</span></span><br><span class="line">    <span class="comment">// communicate with.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务器端</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">server_end_point</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Step 1. Here we assume that the server application has</span></span><br><span class="line">    <span class="comment">// already obtained the protocol port number.</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> port_num = <span class="number">3333</span>;</span><br><span class="line">    <span class="comment">// Step 2. Create special object of asio::ip::address class</span></span><br><span class="line">    <span class="comment">// that specifies all IP-addresses available on the host. Note</span></span><br><span class="line">    <span class="comment">// that here we assume that server works over IPv6 protocol.</span></span><br><span class="line">    asio::ip::address ip_address = asio::ip::address_v6::<span class="built_in">any</span>();</span><br><span class="line">    <span class="comment">// Step 3.</span></span><br><span class="line">    asio::ip::<span class="function">tcp::endpoint <span class="title">ep</span><span class="params">(ip_address, port_num)</span></span>;</span><br><span class="line">    <span class="comment">// Step 4. The endpoint is created and can be used to</span></span><br><span class="line">    <span class="comment">// specify the IP addresses and a port number on which</span></span><br><span class="line">    <span class="comment">// the server application wants to listen for incoming</span></span><br><span class="line">    <span class="comment">// connections.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// socket 创建分为四步 创建上下文iocontext，选择协议，生成socket，打开socket。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">create_tcp_socket</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Step 1. An instance of &#x27;io_service&#x27; class is required by</span></span><br><span class="line">    <span class="comment">// socket constructor.</span></span><br><span class="line">    asio::io_context ios;</span><br><span class="line">    <span class="comment">// Step 2. Creating an object of &#x27;tcp&#x27; class representing</span></span><br><span class="line">    <span class="comment">// a TCP protocol with IPv4 as underlying protocol.</span></span><br><span class="line">    asio::ip::tcp protocol = asio::ip::tcp::<span class="built_in">v4</span>();</span><br><span class="line">    <span class="comment">// Step 3. Instantiating an active TCP socket object.</span></span><br><span class="line">    asio::ip::<span class="function">tcp::socket <span class="title">sock</span><span class="params">(ios)</span></span>;</span><br><span class="line">    <span class="comment">// Used to store information about error that happens</span></span><br><span class="line">    <span class="comment">// while opening the socket.</span></span><br><span class="line">    boost::system::error_code ec;</span><br><span class="line">    <span class="comment">// Step 4. Opening the socket.</span></span><br><span class="line">    sock.<span class="built_in">open</span>(protocol, ec);</span><br><span class="line">    <span class="keyword">if</span> (ec.<span class="built_in">value</span>() != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Failed to open the socket.</span></span><br><span class="line">        std::cout</span><br><span class="line">            &lt;&lt; <span class="string">&quot;Failed to open the socket! Error code = &quot;</span></span><br><span class="line">            &lt;&lt; ec.<span class="built_in">value</span>() &lt;&lt; <span class="string">&quot;. Message: &quot;</span> &lt;&lt; ec.<span class="built_in">message</span>();</span><br><span class="line">        <span class="keyword">return</span> ec.<span class="built_in">value</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上述socket只是通信的socket，如果是服务端，我们还需要生成一个acceptor的socket，用来接收新的连接。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">create_acceptor_socket</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Step 1. An instance of &#x27;io_service&#x27; class is required by</span></span><br><span class="line">    <span class="comment">// socket constructor.</span></span><br><span class="line">    asio::io_context ios;</span><br><span class="line">    <span class="comment">// Step 2. Creating an object of &#x27;tcp&#x27; class representing</span></span><br><span class="line">    <span class="comment">// a TCP protocol with IPv6 as underlying protocol.</span></span><br><span class="line">    asio::ip::tcp protocol = asio::ip::tcp::<span class="built_in">v6</span>();</span><br><span class="line">    <span class="comment">// Step 3. Instantiating an acceptor socket object.</span></span><br><span class="line">    asio::ip::<span class="function">tcp::acceptor <span class="title">acceptor</span><span class="params">(ios)</span></span>;</span><br><span class="line">    <span class="comment">// Used to store information about error that happens</span></span><br><span class="line">    <span class="comment">// while opening the acceptor socket.</span></span><br><span class="line">    boost::system::error_code ec;</span><br><span class="line">    <span class="comment">// Step 4. Opening the acceptor socket.</span></span><br><span class="line">    acceptor.<span class="built_in">open</span>(protocol, ec);</span><br><span class="line">    <span class="keyword">if</span> (ec.<span class="built_in">value</span>() != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Failed to open the socket.</span></span><br><span class="line">        std::cout</span><br><span class="line">            &lt;&lt; <span class="string">&quot;Failed to open the acceptor socket!&quot;</span></span><br><span class="line">            &lt;&lt; <span class="string">&quot;Error code = &quot;</span></span><br><span class="line">            &lt;&lt; ec.<span class="built_in">value</span>() &lt;&lt; <span class="string">&quot;. Message: &quot;</span> &lt;&lt; ec.<span class="built_in">message</span>();</span><br><span class="line">        <span class="keyword">return</span> ec.<span class="built_in">value</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 绑定acceptor 对于acceptor类型的socket，服务器要将其绑定到指定的断点,所有连接这个端点的连接都可以被接收到。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bind_acceptor_socket</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Step 1. Here we assume that the server application has</span></span><br><span class="line">    <span class="comment">// already obtained the protocol port number.</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> port_num = <span class="number">3333</span>;</span><br><span class="line">    <span class="comment">// Step 2. Creating an endpoint.</span></span><br><span class="line">    asio::ip::<span class="function">tcp::endpoint <span class="title">ep</span><span class="params">(asio::ip::address_v4::any(),</span></span></span><br><span class="line"><span class="params"><span class="function">                            port_num)</span></span>;</span><br><span class="line">    <span class="comment">// Used by &#x27;acceptor&#x27; class constructor.</span></span><br><span class="line">    asio::io_context ios;</span><br><span class="line">    <span class="comment">// Step 3. Creating and opening an acceptor socket.</span></span><br><span class="line">    asio::ip::<span class="function">tcp::acceptor <span class="title">acceptor</span><span class="params">(ios, ep.protocol())</span></span>;</span><br><span class="line">    boost::system::error_code ec;</span><br><span class="line">    <span class="comment">// Step 4. Binding the acceptor socket.</span></span><br><span class="line">    acceptor.<span class="built_in">bind</span>(ep, ec);</span><br><span class="line">    <span class="comment">// Handling errors if any.</span></span><br><span class="line">    <span class="keyword">if</span> (ec.<span class="built_in">value</span>() != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Failed to bind the acceptor socket. Breaking</span></span><br><span class="line">        <span class="comment">// execution.</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to bind the acceptor socket.&quot;</span></span><br><span class="line">                &lt;&lt; <span class="string">&quot;Error code = &quot;</span> &lt;&lt; ec.<span class="built_in">value</span>() &lt;&lt; <span class="string">&quot;. Message: &quot;</span></span><br><span class="line">                &lt;&lt; ec.<span class="built_in">message</span>();</span><br><span class="line">        <span class="keyword">return</span> ec.<span class="built_in">value</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接指定的端点 作为客户端可以连接服务器指定的端点进行连接</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">connect_to_end</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Step 1. Assume that the client application has already</span></span><br><span class="line">    <span class="comment">// obtained the IP address and protocol port number of the</span></span><br><span class="line">    <span class="comment">// target server.</span></span><br><span class="line">    std::string raw_ip_address = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> port_num = <span class="number">3333</span>;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Step 2. Creating an endpoint designating</span></span><br><span class="line">        <span class="comment">// a target server application.</span></span><br><span class="line">        asio::ip::<span class="function">tcp::endpoint</span></span><br><span class="line"><span class="function">            <span class="title">ep</span><span class="params">(asio::ip::address::from_string(raw_ip_address),</span></span></span><br><span class="line"><span class="params"><span class="function">            port_num)</span></span>;</span><br><span class="line">        asio::io_context ios;</span><br><span class="line">        <span class="comment">// Step 3. Creating and opening a socket.</span></span><br><span class="line">        asio::ip::<span class="function">tcp::socket <span class="title">sock</span><span class="params">(ios, ep.protocol())</span></span>;</span><br><span class="line">        <span class="comment">// Step 4. Connecting a socket.</span></span><br><span class="line">        sock.<span class="built_in">connect</span>(ep);</span><br><span class="line">        <span class="comment">// At this point socket &#x27;sock&#x27; is connected to</span></span><br><span class="line">        <span class="comment">// the server application and can be used</span></span><br><span class="line">        <span class="comment">// to send data to or receive data from it.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Overloads of asio::ip::address::from_string() and</span></span><br><span class="line">    <span class="comment">// asio::ip::tcp::socket::connect() used here throw</span></span><br><span class="line">    <span class="comment">// exceptions in case of error condition.</span></span><br><span class="line">    <span class="built_in">catch</span> (system::system_error &amp;e)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Error occured! Error code = &quot;</span> &lt;&lt; e.<span class="built_in">code</span>()</span><br><span class="line">                &lt;&lt; <span class="string">&quot;. Message: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>();</span><br><span class="line">        <span class="keyword">return</span> e.<span class="built_in">code</span>().<span class="built_in">value</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务器接收连接 当有客户端连接时，服务器需要接收连接</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">accept_new_connection</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// The size of the queue containing the pending connection</span></span><br><span class="line">    <span class="comment">// requests.</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> BACKLOG_SIZE = <span class="number">30</span>;</span><br><span class="line">    <span class="comment">// Step 1. Here we assume that the server application has</span></span><br><span class="line">    <span class="comment">// already obtained the protocol port number.</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> port_num = <span class="number">3333</span>;</span><br><span class="line">    <span class="comment">// Step 2. Creating a server endpoint.</span></span><br><span class="line">    asio::ip::<span class="function">tcp::endpoint <span class="title">ep</span><span class="params">(asio::ip::address_v4::any(),</span></span></span><br><span class="line"><span class="params"><span class="function">                            port_num)</span></span>;</span><br><span class="line">    asio::io_context ios;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Step 3. Instantiating and opening an acceptor socket.</span></span><br><span class="line">        asio::ip::<span class="function">tcp::acceptor <span class="title">acceptor</span><span class="params">(ios, ep.protocol())</span></span>;</span><br><span class="line">        <span class="comment">// Step 4. Binding the acceptor socket to the</span></span><br><span class="line">        <span class="comment">// server endpint.</span></span><br><span class="line">        acceptor.<span class="built_in">bind</span>(ep);</span><br><span class="line">        <span class="comment">// Step 5. Starting to listen for incoming connection</span></span><br><span class="line">        <span class="comment">// requests.</span></span><br><span class="line">        acceptor.<span class="built_in">listen</span>(BACKLOG_SIZE);</span><br><span class="line">        <span class="comment">// Step 6. Creating an active socket.</span></span><br><span class="line">        asio::ip::<span class="function">tcp::socket <span class="title">sock</span><span class="params">(ios)</span></span>;</span><br><span class="line">        <span class="comment">// Step 7. Processing the next connection request and</span></span><br><span class="line">        <span class="comment">// connecting the active socket to the client.</span></span><br><span class="line">        acceptor.<span class="built_in">accept</span>(sock);</span><br><span class="line">        <span class="comment">// At this point &#x27;sock&#x27; socket is connected to</span></span><br><span class="line">        <span class="comment">// the client application and can be used to send data to</span></span><br><span class="line">        <span class="comment">// or receive data from it.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (system::system_error &amp;e)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Error occured! Error code = &quot;</span> &lt;&lt; e.<span class="built_in">code</span>()</span><br><span class="line">                &lt;&lt; <span class="string">&quot;. Message: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>();</span><br><span class="line">        <span class="keyword">return</span> e.<span class="built_in">code</span>().<span class="built_in">value</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">关于buffer</span></span><br><span class="line"><span class="comment">任何网络库都有提供buffer的数据结构，所谓buffer就是接收和发送数据时缓存数据的结构。</span></span><br><span class="line"><span class="comment">boost::asio提供了asio::mutable_buffer 和 asio::const_buffer这两个结构，他们是一段连续的空间，首字节存储了后续数据的长度。</span></span><br><span class="line"><span class="comment">asio::mutable_buffer用于写服务，asio::const_buffer用于读服务。但是这两个结构都没有被asio的api直接使用。</span></span><br><span class="line"><span class="comment">对于api的buffer参数，asio提出了MutableBufferSequence和ConstBufferSequence概念，他们是由多个asio::mutable_buffer和asio::const_buffer组成的。也就是说boost::asio为了节省空间，将一部分连续的空间组合起来，作为参数交给api使用。</span></span><br><span class="line"><span class="comment">我们可以理解为MutableBufferSequence的数据结构为std::vector&lt;asio::mutable_buffer&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ConstBufferSequence&gt;</span></span><br><span class="line"><span class="function">std::<span class="type">size_t</span> <span class="title">send</span><span class="params">(<span class="type">const</span> ConstBufferSequence &amp; buffers)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">client_end_point</span>();</span><br><span class="line">    <span class="built_in">server_end_point</span>();</span><br><span class="line">    <span class="built_in">create_tcp_socket</span>();</span><br><span class="line">    <span class="built_in">create_acceptor_socket</span>();</span><br><span class="line">    <span class="built_in">bind_acceptor_socket</span>();</span><br><span class="line">    <span class="built_in">connect_to_end</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="asio-同步服务器及客户端示例代码"><a href="#asio-同步服务器及客户端示例代码" class="headerlink" title="asio 同步服务器及客户端示例代码"></a>asio 同步服务器及客户端示例代码</h2><ul>
<li>server端  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost::asio::ip;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> std::shared_ptr&lt;tcp::socket&gt; socket_ptr;</span><br><span class="line">std::set&lt;std::shared_ptr&lt;std::thread&gt;&gt; thread_set;</span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> MAX_LENGTH = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">session</span><span class="params">(socket_ptr sock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(;;)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span> data[MAX_LENGTH];</span><br><span class="line">            <span class="built_in">memset</span>(data, <span class="string">&#x27;\0&#x27;</span>, MAX_LENGTH);</span><br><span class="line">            </span><br><span class="line">            boost::system::error_code error;</span><br><span class="line">            <span class="comment">// size_t length = boost::asio::read(sock, boost::asio::buffer(data, MAX_LENGTH), error);</span></span><br><span class="line">            <span class="comment">// size_t length = sock-&gt;read_some(boost::asio::buffer(data, MAX_LENGTH), error);</span></span><br><span class="line">            <span class="type">size_t</span> length = sock-&gt;<span class="built_in">read_some</span>(boost::asio::<span class="built_in">buffer</span>(data, MAX_LENGTH), error);</span><br><span class="line">            <span class="keyword">if</span>( error == boost::asio::error::eof)</span><br><span class="line">            &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;connect close &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (error)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> boost::system::<span class="built_in">system_error</span>(error);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;receive form &quot;</span> &lt;&lt; sock-&gt;<span class="built_in">remote_endpoint</span>().<span class="built_in">address</span>().<span class="built_in">to_string</span>() &lt;&lt; std::endl;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;receive data &quot;</span> &lt;&lt; data&lt;&lt; <span class="string">&quot;length: &quot;</span> &lt;&lt; length &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">            boost::asio::<span class="built_in">write</span>(*sock, boost::asio::<span class="built_in">buffer</span>(data, length));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span>(<span class="type">const</span> std::exception&amp; e)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">server</span><span class="params">(boost::asio::io_context &amp;ioc, <span class="type">unsigned</span> <span class="type">short</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">tcp::acceptor <span class="title">a</span><span class="params">(ioc, tcp::endpoint(tcp::v4(), port))</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">socket_ptr <span class="title">socket</span><span class="params">(<span class="keyword">new</span> tcp::socket(ioc))</span></span>;</span><br><span class="line">        a.<span class="built_in">accept</span>(*socket);</span><br><span class="line">        <span class="keyword">auto</span> t = std::<span class="built_in">make_shared</span>&lt;std::thread&gt;(session, socket);</span><br><span class="line"></span><br><span class="line">        thread_set.<span class="built_in">insert</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        boost::asio::io_context ioc;</span><br><span class="line">        <span class="built_in">server</span>(ioc, <span class="number">10086</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; t: thread_set)</span><br><span class="line">        &#123;</span><br><span class="line">            t-&gt;<span class="built_in">join</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span>(<span class="type">const</span> std::exception&amp; e)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>客户端  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost::asio::ip;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> MAX_LENGTH = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建上下文对象</span></span><br><span class="line">        boost::asio::io_context ioc;</span><br><span class="line">        <span class="comment">// 构造endpoint 节点</span></span><br><span class="line">        <span class="function">tcp::endpoint <span class="title">remote_ep</span><span class="params">(address::from_string(<span class="string">&quot;127.0.0.1&quot;</span>), <span class="number">10086</span>)</span></span>;</span><br><span class="line">        <span class="function">tcp::socket <span class="title">sock</span><span class="params">(ioc)</span></span>;</span><br><span class="line">        boost::system::error_code error = boost::asio::error::host_not_found;</span><br><span class="line">        sock.<span class="built_in">connect</span>(remote_ep, error);</span><br><span class="line">        <span class="keyword">if</span>(error)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; error &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; error.<span class="built_in">message</span>() &lt;&lt; std::endl;</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ENTER MESSAGE: &quot;</span>;</span><br><span class="line">        <span class="type">char</span> request[MAX_LENGTH]&#123;&#125;;</span><br><span class="line">        std::cin.<span class="built_in">getline</span>(request, MAX_LENGTH);</span><br><span class="line">        <span class="type">size_t</span> request_length = <span class="built_in">strlen</span>(request);</span><br><span class="line">        boost::asio::<span class="built_in">write</span>(sock, boost::asio::<span class="built_in">buffer</span>(request, request_length));</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> reply[MAX_LENGTH]&#123;&#125;;</span><br><span class="line">        <span class="type">size_t</span> reply_length = boost::asio::<span class="built_in">read</span>(sock, boost::asio::<span class="built_in">buffer</span>(reply, request_length));</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;reply is: &quot;</span>;</span><br><span class="line">        std::cout.<span class="built_in">write</span>(reply, reply_length);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span>(<span class="type">const</span> std::exception&amp; e)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
asio 异步网络</li>
<li>服务端 session  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/uuid.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CServer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_LENGTH = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CSession</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CServer</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MsgNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">CSession</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MsgNode</span>(<span class="type">char</span> *msg, <span class="type">int</span> max_len) : <span class="built_in">max_len_</span>(max_len)</span><br><span class="line">    &#123;</span><br><span class="line">        data_ = <span class="keyword">new</span> <span class="type">char</span>[max_len];</span><br><span class="line">        <span class="built_in">memcpy</span>(data_, msg, max_len);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">MsgNode</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] data_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> curr_len_;</span><br><span class="line">    <span class="type">int</span> max_len_;</span><br><span class="line">    <span class="type">char</span> *data_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CSession</span> : <span class="keyword">public</span> std::enable_shared_from_this&lt;CSession&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CSession</span>(boost::asio::io_context &amp;ioc, CServer *server);</span><br><span class="line">    ~<span class="built_in">CSession</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Session is destruct !&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    boost::asio::ip::<span class="function">tcp::socket &amp;<span class="title">getSocket</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">std::string &amp;<span class="title">getUuid</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">send</span><span class="params">(<span class="type">char</span> *msg, <span class="type">int</span> max_length)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleWrite</span><span class="params">(<span class="type">const</span> boost::system::error_code &amp;ec, std::shared_ptr&lt;CSession&gt; _self_shared)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleRead</span><span class="params">(<span class="type">const</span> boost::system::error_code &amp;ec, std::<span class="type">size_t</span> bytes_transferred, std::shared_ptr&lt;CSession&gt; _self_shared)</span></span>;</span><br><span class="line">    boost::asio::ip::tcp::socket socket_;</span><br><span class="line">    std::string uuid_;</span><br><span class="line">    <span class="type">char</span> data_[MAX_LENGTH];</span><br><span class="line">    CServer *server_;</span><br><span class="line">    std::queue&lt;std::shared_ptr&lt;MsgNode&gt;&gt; send_que_;</span><br><span class="line">    std::mutex send_lock_mtx_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CSession.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line">CSession::<span class="built_in">CSession</span>(boost::asio::io_context &amp;ioc, CServer *server) : <span class="built_in">socket_</span>(ioc), <span class="built_in">server_</span>(server)</span><br><span class="line">&#123;</span><br><span class="line">    boost::uuids::uuid a_uuid = boost::uuids::<span class="built_in">random_generator</span>()();</span><br><span class="line">    uuid_ = boost::uuids::<span class="built_in">to_string</span>(a_uuid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">boost::asio::ip::<span class="function">tcp::socket &amp;<span class="title">CSession::getSocket</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> socket_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string &amp;<span class="title">CSession::getUuid</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> uuid_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(data_, <span class="number">0</span>, MAX_LENGTH);</span><br><span class="line">    socket_.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(data_, MAX_LENGTH),</span><br><span class="line">                            std::<span class="built_in">bind</span>(&amp;CSession::handleRead, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, <span class="built_in">shared_from_this</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::send</span><span class="params">(<span class="type">char</span> *msg, <span class="type">int</span> max_length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> panding = <span class="literal">false</span>;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(send_lock_mtx_)</span></span>;</span><br><span class="line">    send_que_.<span class="built_in">push</span>(std::<span class="built_in">make_shared</span>&lt;MsgNode&gt;(msg, max_length));</span><br><span class="line">    <span class="keyword">if</span> (send_que_.<span class="built_in">size</span>() &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        panding = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    socket_.<span class="built_in">async_send</span>(boost::asio::<span class="built_in">buffer</span>(msg, max_length),</span><br><span class="line">                    std::<span class="built_in">bind</span>(&amp;CSession::handleWrite, <span class="keyword">this</span>, std::placeholders::_1, <span class="built_in">shared_from_this</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::handleWrite</span><span class="params">(<span class="type">const</span> boost::system::error_code &amp;ec, std::shared_ptr&lt;CSession&gt; _self_shared)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!ec)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(send_lock_mtx_)</span></span>;</span><br><span class="line">        send_que_.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (!send_que_.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> &amp;msg_node = send_que_.<span class="built_in">front</span>();</span><br><span class="line">            socket_.<span class="built_in">async_send</span>(boost::asio::<span class="built_in">buffer</span>(msg_node-&gt;data_, msg_node-&gt;max_len_),</span><br><span class="line">                            std::<span class="built_in">bind</span>(&amp;CSession::handleWrite, <span class="keyword">this</span>, std::placeholders::_1, _self_shared));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;handle write failed, err is &quot;</span> &lt;&lt; ec.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">        server_-&gt;<span class="built_in">clearSession</span>(uuid_);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::handleRead</span><span class="params">(<span class="type">const</span> boost::system::error_code &amp;ec, std::<span class="type">size_t</span> bytes_transferred, std::shared_ptr&lt;CSession&gt; _self_shared)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!ec)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;read data: &quot;</span> &lt;&lt; data_ &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">send</span>(data_, bytes_transferred);</span><br><span class="line">        <span class="built_in">memset</span>(data_, <span class="number">0</span>, MAX_LENGTH);</span><br><span class="line">        socket_.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(data_, MAX_LENGTH),</span><br><span class="line">                                std::<span class="built_in">bind</span>(&amp;CSession::handleRead, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, <span class="built_in">shared_from_this</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;handle read failed, error is &quot;</span> &lt;&lt; ec.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">        server_-&gt;<span class="built_in">clearSession</span>(uuid_);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>服务端 server  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;CSession.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> MAX_LENGTH;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CSession</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CServer</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CServer</span>(boost::asio::io_context &amp;ioc, <span class="type">short</span> port);</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clearSession</span><span class="params">(std::string &amp;)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    boost::asio::io_context &amp;ioc_;</span><br><span class="line">    <span class="type">short</span> port_;</span><br><span class="line">    boost::asio::ip::tcp::acceptor acceptor_;</span><br><span class="line">    std::map&lt;std::string, std::shared_ptr&lt;CSession&gt;&gt; sessions_;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleAccept</span><span class="params">(std::shared_ptr&lt;CSession&gt;, <span class="type">const</span> boost::system::error_code &amp;ec)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">startAccept</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CServer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">CServer::<span class="built_in">CServer</span>(boost::asio::io_context &amp;ioc, <span class="type">short</span> port) : <span class="built_in">ioc_</span>(ioc), <span class="built_in">port_</span>(port), </span><br><span class="line"><span class="built_in">acceptor_</span>(ioc,boost::asio::ip::tcp::<span class="built_in">endpoint</span>(boost::asio::ip::tcp::<span class="built_in">v4</span>(),port))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">startAccept</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CServer::clearSession</span><span class="params">(std::string &amp;uuid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sessions_.<span class="built_in">erase</span>(uuid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CServer::handleAccept</span><span class="params">(std::shared_ptr&lt;CSession&gt; new_session, <span class="type">const</span> boost::system::error_code &amp;ec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!ec)</span><br><span class="line">    &#123;</span><br><span class="line">        new_session-&gt;<span class="built_in">start</span>();</span><br><span class="line">        sessions_.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(new_session-&gt;<span class="built_in">getUuid</span>(), new_session));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;session accept failed, error is &quot;</span> &lt;&lt; ec.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">startAccept</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CServer::startAccept</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::shared_ptr&lt;CSession&gt; new_session = std::<span class="built_in">make_shared</span>&lt;CSession&gt;(ioc_, <span class="keyword">this</span>);</span><br><span class="line">    acceptor_.<span class="built_in">async_accept</span>(new_session-&gt;<span class="built_in">getSocket</span>(),</span><br><span class="line">                        std::<span class="built_in">bind</span>(&amp;CServer::handleAccept, <span class="keyword">this</span>, new_session, std::placeholders::_1));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;CServer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        boost::asio::io_context ioc;</span><br><span class="line">        <span class="function">CServer <span class="title">s</span><span class="params">(ioc, <span class="number">10086</span>)</span></span>;</span><br><span class="line">        ioc.<span class="built_in">run</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span>(std::exception &amp;e)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>服务器通信</tag>
      </tags>
  </entry>
</search>
