<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>MarkDown语法</title>
    <url>/Lei_Blog/2024/11/01/MarkDown%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>MarkDown基础语法</p>
<h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>使用符号（#&#x2F;&#x3D;），最多支持六级标题，最好在符号后加上空格<br></p>
<ul>
<li># &emsp;一级标题<br></li>
<li>## &emsp;二级标题<br></li>
<li>### &emsp;三级标题<br></li>
</ul>
<h2 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h2><h3 id="语法如下"><a href="#语法如下" class="headerlink" title="语法如下"></a>语法如下</h3><ul>
<li>如果行与行之间没有空行则会被视为一段，若之间有有空行则视为不同段落</li>
<li>空行是指行内什么都没有，或只有空格和制表符</li>
<li>如果想在段内直接换行则需要在上一行的结尾插入两个以上的空格然后回车</li>
<li>当超过80个字符或以（。！?）等结尾时建议换行，或URL较长时换行</li>
</ul>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="有序列表语法如下"><a href="#有序列表语法如下" class="headerlink" title="有序列表语法如下"></a>有序列表语法如下</h3><ul>
<li>数字序号 + 英文句号 + 空格 + 列表内容     <ol>
<li>我是第一行</li>
<li>我是第二行</li>
<li>……..</li>
</ol>
</li>
<li>无序列表如下<br>*&#x2F;+&#x2F;- + 空格 + 列表内容</li>
</ul>
<h3 id="列表嵌套语法如下"><a href="#列表嵌套语法如下" class="headerlink" title="列表嵌套语法如下"></a>列表嵌套语法如下</h3><ul>
<li>- 第一层列表<br>tab + 第二层列表<br>tab+ tab + 第三层列表<br><br></li>
<li>第一层列表<ul>
<li>第二层列表<ul>
<li>第三层列表<ul>
<li>…..</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="图片插入"><a href="#图片插入" class="headerlink" title="图片插入"></a>图片插入</h2><h3 id="图片插入语法文字链接如下"><a href="#图片插入语法文字链接如下" class="headerlink" title="图片插入语法文字链接如下"></a>图片插入语法文字链接如下</h3><ul>
<li>![图片替代文字](图片替代地址)</li>
<li>[链接文字](链接地址)<ul>
<li>引用连接：<br><br>   [链接文字][链接标记]<br>   ……<br>   在底部:<br>   [链接标记]: 链接地址</li>
</ul>
</li>
</ul>
<h3 id="引用链接"><a href="#引用链接" class="headerlink" title="引用链接"></a>引用链接</h3><ul>
<li>链接标记可以有字母、数字、空格和标点符号</li>
<li>链接标记不区分大小写</li>
<li>定义的链接内容可以放在当前文件的任意位置、建议放在页尾巴</li>
<li>当链接地址为网络地址时要以http&#x2F;https开头，否则会被标识为本地地址</li>
</ul>
<h2 id="行内代码块"><a href="#行内代码块" class="headerlink" title="行内代码块"></a>行内代码块</h2><ul>
<li><p>行内代码引用要使用`包裹，语法如下<br>使用`cd..` -&gt; <code>CD .. </code> </p>
</li>
<li><p>代码块.TAB键或者4个空格开头</p>
<pre><code>  def test_print():
      pass
</code></pre>
</li>
</ul>
<h3 id="使用规范"><a href="#使用规范" class="headerlink" title="使用规范"></a>使用规范</h3><pre><code>    <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;aabb&quot;</span>)</span><br></pre></td></tr></table></figure>

    <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">include&lt;iostream&gt;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;test&quot;</span></span></span><br><span class="line">test</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">which</span> bash</span></span><br><span class="line">/bin/bash</span><br></pre></td></tr></table></figure>
</code></pre>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><h3 id="语法如下-1"><a href="#语法如下-1" class="headerlink" title="语法如下"></a>语法如下</h3><p>引用由&gt;+ 引用内容来标记</p>
<ul>
<li>多行引用也可以在每一行的开有都插入&gt;</li>
<li>在引用中可以嵌套引用</li>
<li>在引用中可以使用其它MarkDown语法</li>
<li>段落与换行的格式在引用中也是可以适用的<ul>
<li>示例    <blockquote>
<p>例子1   </p>
</blockquote>
 正常的句子<blockquote>
<p>多行引用第一行<br> 第二行</p>
</blockquote>
</li>
<li>引用嵌套<blockquote>
<p>引用嵌套 &gt;</p>
<blockquote>
<p>被嵌套部分 &gt;  &gt;</p>
</blockquote>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="GFM语法"><a href="#GFM语法" class="headerlink" title="GFM语法"></a>GFM语法</h2><h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><ul>
<li>~~被删除的文字~~<br><del>被删除的文字</del></li>
</ul>
<h3 id="表情符号"><a href="#表情符号" class="headerlink" title="表情符号"></a>表情符号</h3><ul>
<li>表情符号 :表情代码:<br>   :smile:<br>   :laughing:<br>   :+1:</li>
</ul>
<h3 id="自动链接"><a href="#自动链接" class="headerlink" title="自动链接"></a>自动链接</h3><ul>
<li>由&lt;&gt;包裹的URL地址被自动识别并解析为超链接<br>百度<a href="https://www.baidu.com/">https://www.baidu.com</a></li>
</ul>
<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><ul>
<li>表格语法如下     <br> 
\| 表头1 \| 表头2 \| 表头3 \|    
\|----  \|---- \| ----\|    
\| 内容1 \| 内容2\| 内容3\|   
<br>

<table>
<thead>
<tr>
<th>表头1</th>
<th>表头2</th>
<th>表头3</th>
</tr>
</thead>
<tbody><tr>
<td>内容1</td>
<td>内容2</td>
<td>内容3</td>
</tr>
<tr>
<td>内容1</td>
<td>内容2</td>
<td>内容3</td>
</tr>
</tbody></table>
</li>
<li>默认对齐<ul>
<li><p>左对齐【默认】 :</p>
</li>
<li><p>右对齐   -：</p>
</li>
<li><p>中间对齐 :-:    </p>
<p>中间对齐 |:—-:|:—-:|:—-:|     </p>
<table>
<thead>
<tr>
<th align="center">表头1</th>
<th align="center">表头2</th>
<th align="center">表头3</th>
</tr>
</thead>
<tbody><tr>
<td align="center">内容1</td>
<td align="center">内容2</td>
<td align="center">内容3</td>
</tr>
<tr>
<td align="center">内容1</td>
<td align="center">内容2</td>
<td align="center">内容3</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<h3 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h3><ul>
<li><p>任务列表以-+ 开头，由[+空格/X+]组成</p>
</li>
<li><p>X 可以有大小写,看编辑器支持，推荐小写，当中括号内为x时为选中状态    </p>
<ul>
<li><p><input checked="" disabled="" type="checkbox"> 
吃</p>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
喝</p>
</li>
<li><p><input disabled="" type="checkbox"> 
玩  </p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 吃 <ul>
<li><input disabled="" type="checkbox"> 吃鱼</li>
<li><input disabled="" type="checkbox"> 吃饭</li>
</ul>
</li>
</ul>
</li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- [x] 吃</span><br><span class="line">- [x] 喝</span><br><span class="line">- [ ] 玩  </span><br><span class="line"></span><br><span class="line">  - [x] 吃 </span><br><span class="line">    - [ ] 吃鱼</span><br><span class="line">    - [ ] 吃饭   </span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="锚点（书签）"><a href="#锚点（书签）" class="headerlink" title="锚点（书签）"></a>锚点（书签）</h3><p>[锚点描述](#锚点名)</p>
<ul>
<li>锚点名建议使用字母和数字，锚点名是区分大小写的</li>
<li>在锚点中不能含有空格也不能含有特殊字符<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[第一章](#第一章)</span><br><span class="line">[第二章](#第二章)</span><br></pre></td></tr></table></figure>

  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## 第一章</span><br><span class="line">baba baba baba</span><br><span class="line">## 第二章</span><br><span class="line">dcdc dcdc dcdc</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>test</title>
    <url>/Lei_Blog/2024/11/01/test/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>C++模板与泛型_基础_01</title>
    <url>/Lei_Blog/2024/11/02/C-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B-%E5%9F%BA%E7%A1%80-01/</url>
    <content><![CDATA[<h1 id="模板与基础知识"><a href="#模板与基础知识" class="headerlink" title="模板与基础知识"></a>模板与基础知识</h1><h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><ul>
<li>基础范例  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">Sub</span><span class="params">(T tv1, T tv2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tv1 - tv2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  在main中添加如下代码  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> subv = <span class="built_in">Sub</span>(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">std::cout &lt;&lt; subv &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
  上述是一个函数模板的典型范例，T为模板参数，准确说是类型模板参数，因为其代表一个类型。    </li>
<li>实例化<br>  用具体的类型代替类型模板参数的过程叫做实例化，也称之为代码生成器。</li>
</ul>
<h2 id="模板参数推断"><a href="#模板参数推断" class="headerlink" title="模板参数推断"></a>模板参数推断</h2><ul>
<li>常规的参数推断  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U, <span class="keyword">typename</span> V&gt;</span></span><br><span class="line"><span class="function">V <span class="title">Add</span><span class="params">(T tv1, U tv2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tv1 + tv2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  这个函数模板中定义了3个类型模板参数T、U，V。当如此实例化并调用<code>std::cout &lt;&lt; Add(15, 17) &lt;&lt; std::endl;</code>，一定会发生错误。<br>  因为编译器无法推断出返回值类型V，因此只能手动指定类型，如：<code>std::cout &lt;&lt; Add&lt;..., ..., double&gt;(15, 17) &lt;&lt; std::endl;</code>,<br>  虽然可以指定一定量的模板参数，但编译器是按顺序来知道指定的类型的，只能按顺序去指定模板参数。例如<code>Add&lt;double&gt;(...,...)</code>就会发生错误，<br>  如改成以下方式就可以成功编译,让编译器去推断T，U：  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> V, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">V <span class="title">Add</span><span class="params">(T tv1, U tv2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tv1 + tv2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>关键字推断auto, decltype<br>  auto 结合decltype构成返回类型后置语法，代码如下：  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Add</span><span class="params">(T tv1, U tv2)</span> -&gt; <span class="title">decltype</span><span class="params">(tv1 + tv2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tv1 + tv2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>自动推断，指定推断，指定空模板参数列表     <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">myDouble</span> <span class="params">(T temp_value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> temp_value * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  自动推断<code>int result = myDouble(12)</code>, 此时推断出T为int类型<br>  指定推断<code>int result = myDouble&lt;int&gt;(12)</code>,指定类型为int类型<br>  指定空模板参数<code>auto result = myDouble&lt;&gt;(12.6)</code>,此时编译器根据函数参数推断出T为double类型，<br>  当前情况与<code>auto result = myDouble(12.6)</code>没什么不同，若存在一个普通的myDouble函数，&lt;&gt;就会<br>  发生作用:      <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">myDouble</span> <span class="params">(<span class="type">double</span> temp_value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> temp_value * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  若进行这般调用<code>auto result = myDouble(12.6)</code>，其会调用普通函数。</li>
</ul>
<h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><p>函数（函数模板）重载的概念：函数名相同，但函数参数或类型不同。编译器会更具具体情况选择编译器认为最合适的函数<br>模板实例化或者普通函数进行调用</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++泛型</tag>
      </tags>
  </entry>
</search>
