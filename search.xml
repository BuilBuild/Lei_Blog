<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>MarkDown语法</title>
    <url>/Lei_Blog/2024/11/01/MarkDown%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>MarkDown基础语法</p>
<h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>使用符号（#&#x2F;&#x3D;），最多支持六级标题，最好在符号后加上空格<br></p>
<ul>
<li># &emsp;一级标题<br></li>
<li>## &emsp;二级标题<br></li>
<li>### &emsp;三级标题<br></li>
</ul>
<h2 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h2><h3 id="语法如下"><a href="#语法如下" class="headerlink" title="语法如下"></a>语法如下</h3><ul>
<li>如果行与行之间没有空行则会被视为一段，若之间有有空行则视为不同段落</li>
<li>空行是指行内什么都没有，或只有空格和制表符</li>
<li>如果想在段内直接换行则需要在上一行的结尾插入两个以上的空格然后回车</li>
<li>当超过80个字符或以（。！?）等结尾时建议换行，或URL较长时换行</li>
</ul>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="有序列表语法如下"><a href="#有序列表语法如下" class="headerlink" title="有序列表语法如下"></a>有序列表语法如下</h3><ul>
<li>数字序号 + 英文句号 + 空格 + 列表内容     <ol>
<li>我是第一行</li>
<li>我是第二行</li>
<li>……..</li>
</ol>
</li>
<li>无序列表如下<br>*&#x2F;+&#x2F;- + 空格 + 列表内容</li>
</ul>
<h3 id="列表嵌套语法如下"><a href="#列表嵌套语法如下" class="headerlink" title="列表嵌套语法如下"></a>列表嵌套语法如下</h3><ul>
<li>- 第一层列表<br>tab + 第二层列表<br>tab+ tab + 第三层列表<br><br></li>
<li>第一层列表<ul>
<li>第二层列表<ul>
<li>第三层列表<ul>
<li>…..</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="图片插入"><a href="#图片插入" class="headerlink" title="图片插入"></a>图片插入</h2><h3 id="图片插入语法文字链接如下"><a href="#图片插入语法文字链接如下" class="headerlink" title="图片插入语法文字链接如下"></a>图片插入语法文字链接如下</h3><ul>
<li>![图片替代文字](图片替代地址)</li>
<li>[链接文字](链接地址)<ul>
<li>引用连接：<br><br>   [链接文字][链接标记]<br>   ……<br>   在底部:<br>   [链接标记]: 链接地址</li>
</ul>
</li>
</ul>
<h3 id="引用链接"><a href="#引用链接" class="headerlink" title="引用链接"></a>引用链接</h3><ul>
<li>链接标记可以有字母、数字、空格和标点符号</li>
<li>链接标记不区分大小写</li>
<li>定义的链接内容可以放在当前文件的任意位置、建议放在页尾巴</li>
<li>当链接地址为网络地址时要以http&#x2F;https开头，否则会被标识为本地地址</li>
</ul>
<h2 id="行内代码块"><a href="#行内代码块" class="headerlink" title="行内代码块"></a>行内代码块</h2><ul>
<li><p>行内代码引用要使用`包裹，语法如下<br>使用`cd..` -&gt; <code>CD .. </code> </p>
</li>
<li><p>代码块.TAB键或者4个空格开头</p>
<pre><code>  def test_print():
      pass
</code></pre>
</li>
</ul>
<h3 id="使用规范"><a href="#使用规范" class="headerlink" title="使用规范"></a>使用规范</h3><pre><code>    <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;aabb&quot;</span>)</span><br></pre></td></tr></table></figure>

    <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">include&lt;iostream&gt;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;test&quot;</span></span></span><br><span class="line">test</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">which</span> bash</span></span><br><span class="line">/bin/bash</span><br></pre></td></tr></table></figure>
</code></pre>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><h3 id="语法如下-1"><a href="#语法如下-1" class="headerlink" title="语法如下"></a>语法如下</h3><p>引用由&gt;+ 引用内容来标记</p>
<ul>
<li>多行引用也可以在每一行的开有都插入&gt;</li>
<li>在引用中可以嵌套引用</li>
<li>在引用中可以使用其它MarkDown语法</li>
<li>段落与换行的格式在引用中也是可以适用的<ul>
<li>示例    <blockquote>
<p>例子1   </p>
</blockquote>
 正常的句子<blockquote>
<p>多行引用第一行<br> 第二行</p>
</blockquote>
</li>
<li>引用嵌套<blockquote>
<p>引用嵌套 &gt;</p>
<blockquote>
<p>被嵌套部分 &gt;  &gt;</p>
</blockquote>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="GFM语法"><a href="#GFM语法" class="headerlink" title="GFM语法"></a>GFM语法</h2><h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><ul>
<li>~~被删除的文字~~<br><del>被删除的文字</del></li>
</ul>
<h3 id="表情符号"><a href="#表情符号" class="headerlink" title="表情符号"></a>表情符号</h3><ul>
<li>表情符号 :表情代码:<br>   :smile:<br>   :laughing:<br>   :+1:</li>
</ul>
<h3 id="自动链接"><a href="#自动链接" class="headerlink" title="自动链接"></a>自动链接</h3><ul>
<li>由&lt;&gt;包裹的URL地址被自动识别并解析为超链接<br>百度<a href="https://www.baidu.com/">https://www.baidu.com</a></li>
</ul>
<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><ul>
<li>表格语法如下     <br> 
\| 表头1 \| 表头2 \| 表头3 \|    
\|----  \|---- \| ----\|    
\| 内容1 \| 内容2\| 内容3\|   
<br>

<table>
<thead>
<tr>
<th>表头1</th>
<th>表头2</th>
<th>表头3</th>
</tr>
</thead>
<tbody><tr>
<td>内容1</td>
<td>内容2</td>
<td>内容3</td>
</tr>
<tr>
<td>内容1</td>
<td>内容2</td>
<td>内容3</td>
</tr>
</tbody></table>
</li>
<li>默认对齐<ul>
<li><p>左对齐【默认】 :</p>
</li>
<li><p>右对齐   -：</p>
</li>
<li><p>中间对齐 :-:    </p>
<p>中间对齐 |:—-:|:—-:|:—-:|     </p>
<table>
<thead>
<tr>
<th align="center">表头1</th>
<th align="center">表头2</th>
<th align="center">表头3</th>
</tr>
</thead>
<tbody><tr>
<td align="center">内容1</td>
<td align="center">内容2</td>
<td align="center">内容3</td>
</tr>
<tr>
<td align="center">内容1</td>
<td align="center">内容2</td>
<td align="center">内容3</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<h3 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h3><ul>
<li><p>任务列表以-+ 开头，由[+空格/X+]组成</p>
</li>
<li><p>X 可以有大小写,看编辑器支持，推荐小写，当中括号内为x时为选中状态    </p>
<ul>
<li><p><input checked="" disabled="" type="checkbox"> 
吃</p>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
喝</p>
</li>
<li><p><input disabled="" type="checkbox"> 
玩  </p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 吃 <ul>
<li><input disabled="" type="checkbox"> 吃鱼</li>
<li><input disabled="" type="checkbox"> 吃饭</li>
</ul>
</li>
</ul>
</li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- [x] 吃</span><br><span class="line">- [x] 喝</span><br><span class="line">- [ ] 玩  </span><br><span class="line"></span><br><span class="line">  - [x] 吃 </span><br><span class="line">    - [ ] 吃鱼</span><br><span class="line">    - [ ] 吃饭   </span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="锚点（书签）"><a href="#锚点（书签）" class="headerlink" title="锚点（书签）"></a>锚点（书签）</h3><p>[锚点描述](#锚点名)</p>
<ul>
<li>锚点名建议使用字母和数字，锚点名是区分大小写的</li>
<li>在锚点中不能含有空格也不能含有特殊字符<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[第一章](#第一章)</span><br><span class="line">[第二章](#第二章)</span><br></pre></td></tr></table></figure>

  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## 第一章</span><br><span class="line">baba baba baba</span><br><span class="line">## 第二章</span><br><span class="line">dcdc dcdc dcdc</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>test</title>
    <url>/Lei_Blog/2024/11/01/test/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>C++模板与泛型_基础_01</title>
    <url>/Lei_Blog/2024/11/02/C-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B-%E5%9F%BA%E7%A1%80-01/</url>
    <content><![CDATA[<h1 id="模板与基础知识"><a href="#模板与基础知识" class="headerlink" title="模板与基础知识"></a>模板与基础知识</h1><h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><ul>
<li>基础范例  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">Sub</span><span class="params">(T tv1, T tv2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tv1 - tv2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  在main中添加如下代码  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> subv = <span class="built_in">Sub</span>(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">std::cout &lt;&lt; subv &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
  上述是一个函数模板的典型范例，T为模板参数，准确说是类型模板参数，因为其代表一个类型。    </li>
<li>实例化<br>  用具体的类型代替类型模板参数的过程叫做实例化，也称之为代码生成器。</li>
</ul>
<h2 id="模板参数推断"><a href="#模板参数推断" class="headerlink" title="模板参数推断"></a>模板参数推断</h2><ul>
<li>常规的参数推断  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U, <span class="keyword">typename</span> V&gt;</span></span><br><span class="line"><span class="function">V <span class="title">Add</span><span class="params">(T tv1, U tv2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tv1 + tv2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  这个函数模板中定义了3个类型模板参数T、U，V。当如此实例化并调用<code>std::cout &lt;&lt; Add(15, 17) &lt;&lt; std::endl;</code>，一定会发生错误。<br>  因为编译器无法推断出返回值类型V，因此只能手动指定类型，如：<code>std::cout &lt;&lt; Add&lt;..., ..., double&gt;(15, 17) &lt;&lt; std::endl;</code>,<br>  虽然可以指定一定量的模板参数，但编译器是按顺序来知道指定的类型的，只能按顺序去指定模板参数。例如<code>Add&lt;double&gt;(...,...)</code>就会发生错误，<br>  如改成以下方式就可以成功编译,让编译器去推断T，U：  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> V, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">V <span class="title">Add</span><span class="params">(T tv1, U tv2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tv1 + tv2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>关键字推断auto, decltype<br>  auto 结合decltype构成返回类型后置语法，代码如下：  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Add</span><span class="params">(T tv1, U tv2)</span> -&gt; <span class="title">decltype</span><span class="params">(tv1 + tv2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tv1 + tv2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>自动推断，指定推断，指定空模板参数列表     <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">myDouble</span> <span class="params">(T temp_value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> temp_value * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  自动推断<code>int result = myDouble(12)</code>, 此时推断出T为int类型<br>  指定推断<code>int result = myDouble&lt;int&gt;(12)</code>,指定类型为int类型<br>  指定空模板参数<code>auto result = myDouble&lt;&gt;(12.6)</code>,此时编译器根据函数参数推断出T为double类型，<br>  当前情况与<code>auto result = myDouble(12.6)</code>没什么不同，若存在一个普通的myDouble函数，&lt;&gt;就会<br>  发生作用:      <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">myDouble</span> <span class="params">(<span class="type">double</span> temp_value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> temp_value * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  若进行这般调用<code>auto result = myDouble(12.6)</code>，其会调用普通函数。</li>
</ul>
<h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><p>函数（函数模板）重载的概念：函数名相同，但函数参数或类型不同。编译器会更具具体情况选择编译器认为最合适的函数<br>模板实例化或者普通函数进行调用</p>
<ul>
<li>范例  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myfunc</span><span class="params">(T tmpvalue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;myfunc(T)执行了&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  在main中插入如下代码  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">myfunc</span>(<span class="number">12</span>);</span><br><span class="line"><span class="type">char</span>* p = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="built_in">myfunc</span>(p);</span><br></pre></td></tr></table></figure>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">myfunc(T)执行了</span><br><span class="line">myfunc(T)执行了</span><br></pre></td></tr></table></figure>
  以上编译器可以根据不同的参数实例化不同的模板,现添加如下代码  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myfunc</span><span class="params">(T* tmpvalue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;myfunc(T*)执行了&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  重复上过程，和推断的没有差别  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">myfunc(T)执行了</span><br><span class="line">myfunc(T*)执行了</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="特化"><a href="#特化" class="headerlink" title="特化"></a>特化</h2><p>泛化的意思是“大众化”,特化指的是”大众化“中的指定特征“集合”</p>
<ul>
<li>全特化：模板中所有的参数都指定为特定类型<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tfunc</span><span class="params">(T&amp; tmprv, U&amp; tmprv2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::cout &lt;&lt; “泛化版本执行了” &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">tfunc</span>&lt;<span class="type">int</span>, <span class="type">double</span>&gt;(<span class="type">int</span>&amp; tmprv, <span class="type">double</span>&amp; tmprv2)</span><br><span class="line">&#123;</span><br><span class="line">  std::cout &lt;&lt; “全特化版本执行了” &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> k = <span class="number">12</span>;</span><br><span class="line"><span class="type">double</span> db = <span class="number">15.8</span>;</span><br><span class="line"><span class="built_in">tfunc</span>(k, db);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">全特化版本执行了</span><br></pre></td></tr></table></figure></li>
<li>偏特化(局部特化)<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tfunc</span><span class="params">(T&amp; tmprv, U&amp; tmprv2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::cout &lt;&lt; “泛化版本执行了” &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">模板数量上的偏特化 实际上这条编译会出错，数量上来讲函数模板不能篇特化</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">template&lt;typename U&gt;</span></span><br><span class="line"><span class="comment">void tfunc&lt;int, U&gt;(int&amp; tmprv, U&amp; tmprv2)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  std::cout &lt;&lt; “数量上偏特化版本执行了” &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板范围上的偏特化 实际上是函数模板的重载</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tfunc</span><span class="params">(<span class="type">const</span> T&amp; tmprv, U&amp; tmprv2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::cout &lt;&lt; “模板范围上的偏特化执行了” &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">tfunc</span>(a, b);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">模板范围上的偏特化执行了</span><br></pre></td></tr></table></figure></li>
<li>通过重载实现函数模板的偏特化<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tfunc</span><span class="params">(<span class="type">double</span>&amp; tmprv, U&amp; tmprv2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::cout &lt;&lt; “模板参数数量上的偏特化执行了（重载版本）” &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* p = <span class="string">&quot;aaaaa&quot;</span>;</span><br><span class="line"><span class="type">int</span> i = <span class="number">12</span>;</span><br><span class="line"><span class="built_in">tfunc</span>(p, i);</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> j = <span class="number">19.5</span>;</span><br><span class="line"><span class="built_in">tfunc</span>(j, i);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">泛化版本执行了</span><br><span class="line">模板参数数量上的偏特化执行了（重载版本）</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="非类型模板参数"><a href="#非类型模板参数" class="headerlink" title="非类型模板参数"></a>非类型模板参数</h2><p>模板参数不但可以是一个类型，也可以是一个普通的参数，参数还可以是一个默认值</p>
<ul>
<li>范例<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U, <span class="type">int</span> val </span>= <span class="number">0</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Add</span><span class="params">(T tv1, U tv2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> tv1 + tv2 + val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="built_in">Add</span>&lt;<span class="type">float</span>, <span class="type">float</span>&gt;(<span class="number">1.1f</span>, <span class="number">12.3f</span>) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">Add</span>&lt;<span class="type">float</span>, <span class="type">float</span>, <span class="number">1</span>&gt;(<span class="number">1.1f</span>, <span class="number">12.3f</span>) &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">13.4</span><br><span class="line">14.4</span><br></pre></td></tr></table></figure>
以上要注意的点<ul>
<li>在指定非类型模板参数时，一般给的是常量，否则编译报错。</li>
<li>并不是任何类型的参数都可以，int可以，但float, double类型不行，类类型也不可以，不过double* 等指针类型可以</li>
<li>主要有整型或枚举型，指针类型, 左值引用类型,auto或decltype(auto)这个用法…..</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++泛型</tag>
      </tags>
  </entry>
  <entry>
    <title>vsftpd简单安装和使用</title>
    <url>/Lei_Blog/2024/11/03/vsftpd%E7%AE%80%E5%8D%95%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="Ubuntu系统FTP服务器搭建"><a href="#Ubuntu系统FTP服务器搭建" class="headerlink" title="Ubuntu系统FTP服务器搭建"></a>Ubuntu系统FTP服务器搭建</h2><h3 id="安装vsftpd软件"><a href="#安装vsftpd软件" class="headerlink" title="安装vsftpd软件"></a>安装vsftpd软件</h3><p><a href="https://www.cnblogs.com/HOsystem/p/16629572.html">详细配置说明链接</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install vsftpd</span><br><span class="line"> </span><br><span class="line"># 设置开机启动并启动ftp服务</span><br><span class="line">systemctl enable vsftpd</span><br><span class="line">systemctl start vsftpd</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查看其运行状态</span><br><span class="line">systemctl  status vsftpd</span><br><span class="line">#重启服务</span><br><span class="line">systemctl  restart vsftpd</span><br></pre></td></tr></table></figure>

<h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo useradd -d /home/ftp/ftp_root -m ftpadmin</span><br><span class="line">sudo passwd ftpadmin</span><br><span class="line">输入密码：</span><br><span class="line">再次输入密码：</span><br><span class="line">chmod -R 777 /home/ftp/ftp_root</span><br></pre></td></tr></table></figure>

<h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo nano /etc/vsftpd.conf</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">存在的修改成酱紫：</span><br><span class="line">listen=NO # 阻止 vsftpd 在独立模式下运行</span><br><span class="line">listen_ipv6=YES # vsftpd 将监听 ipv6 而不是 IPv4，你可以根据你的网络情况设置</span><br><span class="line">anonymous_enable=NO # 关闭匿名登录</span><br><span class="line">local_enable=YES # 允许本地用户登录</span><br><span class="line">write_enable=YES # 启用可以修改文件的 FTP 命令</span><br><span class="line">local_umask=022 # 本地用户创建文件的 umask 值</span><br><span class="line">dirmessage_enable=YES # 当用户第一次进入新目录时显示提示消息</span><br><span class="line">xferlog_enable=YES # 一个存有详细的上传和下载信息的日志文件</span><br><span class="line">connect_from_port_20=YES # 在服务器上针对 PORT 类型的连接使用端口 20（FTP 数据）</span><br><span class="line">xferlog_std_format=YES # 保持标准日志文件格式</span><br><span class="line">pam_service_name=vsftpd # vsftpd 将使用的 PAM 验证设备的名字</span><br></pre></td></tr></table></figure>
<p>修改配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/etc/vsftpd.conf </span><br><span class="line">将pam_service_name=vsftpd   修改为：pam_service_name=ftp</span><br></pre></td></tr></table></figure>
<p>最后添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">userlist_deny=NO</span><br><span class="line">userlist_enable=YES</span><br><span class="line">userlist_file=/etc/vsftpd.allowed_users</span><br><span class="line"></span><br><span class="line">nano /etc/vsftpd.chroot_list</span><br><span class="line">#输入ftpadmin后保存退出</span><br><span class="line">开启端口 数据传输20 命令交互21</span><br><span class="line">sudo ufw allow 20</span><br><span class="line">sudo ufw allow 21</span><br><span class="line">#重启服务</span><br><span class="line">systemctl start vsftpd</span><br></pre></td></tr></table></figure>


<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ftp localhost</span></span><br><span class="line">Connected to localhost.</span><br><span class="line">500 OOPS: cannot read user list file:/etc/vsftpd.allowed_users</span><br><span class="line"><span class="meta prompt_">ftp&gt; </span><span class="language-bash"><span class="built_in">exit</span></span></span><br></pre></td></tr></table></figure>
<h2 id="远程登陆"><a href="#远程登陆" class="headerlink" title="远程登陆"></a>远程登陆</h2><h3 id="安装filezilla"><a href="#安装filezilla" class="headerlink" title="安装filezilla"></a>安装filezilla</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install filezilla</span><br></pre></td></tr></table></figure>
<p>输入相关选项即可连接</p>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>vsftpd</tag>
      </tags>
  </entry>
  <entry>
    <title>C++模板与泛型_基础_02</title>
    <url>/Lei_Blog/2024/11/05/C-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B-%E5%9F%BA%E7%A1%80-02/</url>
    <content><![CDATA[<h2 id="类模板、变量模板与别名模板"><a href="#类模板、变量模板与别名模板" class="headerlink" title="类模板、变量模板与别名模板"></a>类模板、变量模板与别名模板</h2><h3 id="类模板的基本范例和模板参数的推断"><a href="#类模板的基本范例和模板参数的推断" class="headerlink" title="类模板的基本范例和模板参数的推断"></a>类模板的基本范例和模板参数的推断</h3><p>类模板，产生类的模具，通过给定的模板参数，生成具体的类</p>
<ul>
<li>基本范例<br>类模板的声明和实现一般都放在同一个头文件中,以下是自定义一个vector<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myvector</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> T* myiterator;</span><br><span class="line">  <span class="comment">//构造函数</span></span><br><span class="line">  <span class="built_in">myvector</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  赋值运算符重载</span></span><br><span class="line"><span class="comment">  在类模板内不使用模板民myvector并不需要提供模板参数，当然也可以提供，可以写成</span></span><br><span class="line"><span class="comment">  myvector&lt;T&gt; </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function">myvector&amp; <span class="title">operator</span><span class="params">(<span class="type">const</span> myvector &amp;)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">myfunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;myfunc 被调用&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">myiterator <span class="title">mybegin</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">myiterator <span class="title">myend</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类外构造</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">myvector&lt;T&gt;::<span class="built_in">myvector</span>()&#123;&#125;</span><br></pre></td></tr></table></figure>
在main函数中插入<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">myvector&lt;<span class="type">int</span>&gt; tmpvec; <span class="comment">// 模板内的T被替换为int</span></span><br><span class="line">tmpvec.<span class="built_in">myfunc</span>();  <span class="comment">// 调用类模板中的普通成员函数</span></span><br></pre></td></tr></table></figure>
运行结果<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">myfunc 被调用</span><br></pre></td></tr></table></figure>
在以上代码中并没有写赋值运算符代码，因为在类模板中只有被调用这些函数编译器才实例化相关代码<br>如果模板中有静态成员函数那么当这个静态成员函数被调用的时候才会实例化，在上代码插入函数，如下<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">mystaticfunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;mystaticfunc() 被调用了&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在main函数中插入<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">myvector&lt;std::string&gt;::<span class="built_in">mystaticfunc</span>();</span><br></pre></td></tr></table></figure>
运行结果<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mystaticfunc() 被调用了</span><br></pre></td></tr></table></figure></li>
<li>模板参数的推断   <ul>
<li>隐式推断<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">A</span>(T val1, T val2)</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;A::A(T val1, T val2)执行了&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
main中插入<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编译器根据参数，推断出类A&lt;int&gt;，进行推断后的代码：A&lt;int&gt; aobj1(15, 16) </span></span><br><span class="line"><span class="function">A <span class="title">aobj1</span><span class="params">(<span class="number">15</span>, <span class="number">16</span>)</span></span>;</span><br></pre></td></tr></table></figure>
结果<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A::A(T val1, T val2)执行了</span><br></pre></td></tr></table></figure>
推断指南的存在意义是为了让编译器推断出模板参数的类型，如<code>A* aobj3=NULL</code>是非法的，可以写成如下形式<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt;</span></span><br><span class="line"><span class="function"><span class="title">A</span><span class="params">(T, T)</span> -&gt; A&lt;<span class="type">double</span>&gt;</span>;</span><br></pre></td></tr></table></figure>
那么代码<code>A aobj(15, 16);</code>类型推断后就会变成<code>A&lt;double&gt; aobj1(15, 16)</code></li>
<li>自定义的推断<br>  让代码编写者按照自己的方式进行推断类型，不进行隐式推断  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt;</span></span><br><span class="line"><span class="function"><span class="title">A</span><span class="params">(T)</span> -&gt; A&lt;T&gt;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//有上代码</span></span></span><br><span class="line"><span class="function">A <span class="title">aobj2</span><span class="params">(<span class="number">12.8</span>)</span></span>; <span class="comment">//有类型推断后相当于A&lt;double&gt; aboj2(12.8)</span></span><br></pre></td></tr></table></figure>
  例子：  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">  T m_b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">B&lt;<span class="type">int</span>&gt; bobj1;</span><br><span class="line">B&lt;<span class="type">int</span>&gt; bobj2&#123;<span class="number">15</span>&#125;;</span><br><span class="line"></span><br><span class="line">B bobj3&#123;<span class="number">15</span>&#125;; <span class="comment">//语法错误 无法推断出bobj3具体类型</span></span><br></pre></td></tr></table></figure>
  针对上错误可以添加一个自定义推断指南  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="title">B</span><span class="params">(T)</span> -&gt; B&lt;T&gt;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="类模板的特化"><a href="#类模板的特化" class="headerlink" title="类模板的特化"></a>类模板的特化</h3><p>开始示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TC</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">TC</span>()</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;TC的泛化版本构造函数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">functest1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;functest1泛化版本&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//mian中添加如下代码</span></span><br><span class="line">TC&lt;<span class="type">int</span>, <span class="type">float</span>&gt; mytc;</span><br><span class="line">mytc.<span class="built_in">functest1</span>();</span><br></pre></td></tr></table></figure>
<p>结果显示</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">TC的泛化版本构造函数</span><br><span class="line">functest1泛化版本</span><br></pre></td></tr></table></figure>
<p>特化的版本是是在泛化的类模板上生成的，先有泛化版本才有特化版本</p>
<ul>
<li>类模板的全特化<br>所谓全特化就是将模板参数全用具体类型指代<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TC</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">TC</span>()</span><br><span class="line">    &#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;TC&lt;int, int&gt;特化版本构造函数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main中添加如下代码</span></span><br><span class="line">TC&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mytc2;</span><br><span class="line">mytc<span class="number">2.f</span>unctest1();</span><br></pre></td></tr></table></figure>
以上会编译报错，因为需要针对特化版本functest1的成员函数进行定义<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TC</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">TC</span>()</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;TC&lt;int, int&gt;特化版本构造函数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">functest1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;functest1特化版本执行了&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">再进行编译，就可以通过了</span><br></pre></td></tr></table></figure>
结果<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TC&lt;int, int&gt;特化版本构造函数</span><br><span class="line">functest1特化版本执行了</span><br></pre></td></tr></table></figure>
对functest1函数在类外编写<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//template&lt;&gt; 这一行不用编写，否则语法报错</span></span><br><span class="line"><span class="type">void</span> TC&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::<span class="built_in">functest1</span>()</span><br><span class="line">&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;functest1泛化版本&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
因为类模板已经全特化，这相当于一个普通类，所以要按照一个普通类的草原函数的实现方法来写</li>
<li>普通成员函数的的全特化    <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">void</span> TC&lt;<span class="type">double</span>, <span class="type">int</span>&gt;::<span class="built_in">functest1</span>()</span><br><span class="line">&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;特化TC&lt;double, int&gt;::functest1() 执行了&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main中添加代码</span></span><br><span class="line">TC&lt;<span class="type">double</span>, <span class="type">int</span>&gt; mytc3;</span><br><span class="line">mytc<span class="number">3.f</span>unctest1();</span><br></pre></td></tr></table></figure>
运行结果<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">TC的泛化版本构造函数</span><br><span class="line">特化TC&lt;double, int&gt;::functest1() 执行了</span><br></pre></td></tr></table></figure></li>
<li>静态成员变量的全特化<br>先在TC类泛化版本中声明静态成员变量<code>static int m_stc;</code><br>然后在类外定义<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="type">int</span> TC&lt;T, U&gt;::m_stc = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在main中添加如下代码</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;mytc3.m_stc = &quot;</span> &lt;&lt; mytc<span class="number">3.</span>m_stc &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
结果<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mytc3.m_stc = 50</span><br></pre></td></tr></table></figure>
对静态成员变量进行全特化<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">int</span> TC&lt;<span class="type">double</span>, <span class="type">int</span>&gt;::m_stc = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在main中添加如下代码</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;mytc3.m_stc = &quot;</span> &lt;&lt; mytc<span class="number">3.</span>m_stc &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
结果<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mytc3.m_stc = 100</span><br></pre></td></tr></table></figure></li>
<li>类模板的偏特化（局部特化）<br>模板参数数量上的偏特化，模板参数范围上的偏特化<ol>
<li>模板参数数量上的偏特化    <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TC</span>&lt;<span class="type">float</span>, U&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">TC</span>()</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;TC&lt;float, U&gt; 偏特化构造函数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">functest1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="type">void</span> TC&lt;<span class="type">float</span>, U&gt;::<span class="built_in">functest1</span>()</span><br><span class="line">&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;TC&lt;float, U&gt;::functest1() 偏特化版本执行了&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main中添加如下代码</span></span><br><span class="line">TC&lt;<span class="type">float</span>, <span class="type">int</span>&gt; mytc4;</span><br><span class="line">mytc<span class="number">4.f</span>unctest1();</span><br></pre></td></tr></table></figure>
 结果 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">TC&lt;float, U&gt; 偏特化构造函数</span><br><span class="line">TC&lt;float, U&gt;::functest1() 偏特化版本执行了</span><br></pre></td></tr></table></figure></li>
<li>模板参数范围上的偏特化    <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TC</span>&lt;<span class="type">const</span> T, U*&gt;</span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">TC</span>()</span><br><span class="line"> &#123;</span><br><span class="line">   std::cout &lt;&lt; <span class="string">&quot;TC&lt;const T, U*&gt; 偏特化版本构造函数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">functest1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="type">void</span> TC&lt;<span class="type">const</span> T, U*&gt;::<span class="built_in">functest1</span>()</span><br><span class="line">&#123;</span><br><span class="line"> std::cout &lt;&lt; <span class="string">&quot;TC&lt;const T, U*&gt;::functest1() 执行了&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在main中添加如下代码</span></span><br><span class="line">TC&lt;<span class="type">const</span> <span class="type">float</span>, <span class="type">int</span> *&gt; mytc5;</span><br><span class="line">mytc<span class="number">5.f</span>unctest1();</span><br></pre></td></tr></table></figure>
结果<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">TC&lt;const T, U*&gt; 偏特化版本构造函数</span><br><span class="line">TC&lt;const T, U*&gt;::functest1() 执行了</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><ul>
<li>常规默认参数<br>类型模板默认参数有一个规矩：如果某个模板参数有默认值，那么从这个有默认值的模板参数开始，后面所有的模板参数都得要有默认值<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T=<span class="type">char</span>, <span class="keyword">typename</span> U=<span class="type">int</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> TC</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mian中可添加如下代码</span></span><br><span class="line">TC&lt;&gt; mytc5;</span><br><span class="line">TC&lt;<span class="type">double</span>&gt; mytc6; </span><br></pre></td></tr></table></figure>
偏特化版本中可以不用有默认值，以下代码编译会报错<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T=<span class="type">char</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> TC&lt;T, <span class="type">int</span>&gt;&#123;&#125;;</span><br></pre></td></tr></table></figure></li>
<li>后面模板参数依赖前模板参数<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U=T*&gt;</span><br><span class="line"><span class="keyword">struct</span> TC&#123;&#125;;</span><br></pre></td></tr></table></figure></li>
<li>在模板中声明指定默认参数<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U, <span class="keyword">typename</span> V=<span class="type">int</span>, <span class="keyword">typename</span> W=<span class="type">char</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> TC;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><ul>
<li>typedef写法<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> TC&lt;<span class="type">int</span>, <span class="type">float</span>&gt; IF_TC;</span><br><span class="line">IF_TC mytc10;</span><br></pre></td></tr></table></figure></li>
<li>using写法<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> IF_TCU = TC&lt;<span class="type">int</span>, <span class="type">float</span>&gt;;</span><br><span class="line">IF_TCU mytc11;</span><br></pre></td></tr></table></figure>
推荐使用using模式</li>
</ul>
<h3 id="非类型模板参数"><a href="#非类型模板参数" class="headerlink" title="非类型模板参数"></a>非类型模板参数</h3><h3 id="成员函数模板"><a href="#成员函数模板" class="headerlink" title="成员函数模板"></a>成员函数模板</h3><ul>
<li>基本含义、构造函数模板</li>
<li>拷贝构造函数模板与拷贝赋值运算符模板</li>
<li>特化</li>
</ul>
<h3 id="类-类模板中的类模板-类模板的嵌套"><a href="#类-类模板中的类模板-类模板的嵌套" class="headerlink" title="类&#x2F;类模板中的类模板(类模板的嵌套)"></a>类&#x2F;类模板中的类模板(类模板的嵌套)</h3><h3 id="变量模板与成员变量模板"><a href="#变量模板与成员变量模板" class="headerlink" title="变量模板与成员变量模板"></a>变量模板与成员变量模板</h3><ul>
<li>变量模板的特化</li>
<li>默认模板参数</li>
<li>非类型模板参数</li>
<li>变量模板的另一种形式</li>
<li>成员变量模板</li>
</ul>
<h3 id="别名模板与成员别名模板"><a href="#别名模板与成员别名模板" class="headerlink" title="别名模板与成员别名模板"></a>别名模板与成员别名模板</h3><h3 id="模板模板参数"><a href="#模板模板参数" class="headerlink" title="模板模板参数"></a>模板模板参数</h3><h3 id="共用体模板"><a href="#共用体模板" class="headerlink" title="共用体模板"></a>共用体模板</h3>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++泛型</tag>
      </tags>
  </entry>
</search>
